<!DOCTYPE html>
<html class="no-js" lang="en">
<html>
<head>
<meta charset="utf-8">
<title>Kotlin</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
</head>
<body>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/basic-syntax.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="basic-syntax">Basic Syntax<a href="#basic-syntax" class="anchor"></a></h1>

<h2 id="defining-packages">Defining packages<a href="#defining-packages" class="anchor"></a></h2>

<p>Package specification should be at the top of the source file:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">package</span> <span class="nn">my.demo</span>

<span class="k">import</span> <span class="nn">java.util.*</span>

<span class="c1">// ...</span></code></pre>

<p>It is not required to match directories and packages: source files can be placed arbitrarily in the file system.</p>

<p>See <a href="packages.html">Packages</a>.</p>

<h2 id="defining-functions">Defining functions<a href="#defining-functions" class="anchor"></a></h2>

<p>Function having two <code>Int</code> parameters with <code>Int</code> return type:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span>
<span class="p">}</span></code></pre>

<p>Function with an expression body and inferred return type:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">=</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span></code></pre>

<p>Function visible from outside of a module should have return type explicitly specified:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">public</span> <span class="k">fun</span> <span class="nf">sum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">a</span> <span class="p">+</span> <span class="n">b</span></code></pre>

<p>Function returning no meaningful value:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">printSum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Unit</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p><code>Unit</code> return type can be omitted:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">public</span> <span class="k">fun</span> <span class="nf">printSum</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="p">+</span> <span class="n">b</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>See <a href="functions.html">Functions</a>.</p>

<h2 id="defining-local-variables">Defining local variables<a href="#defining-local-variables" class="anchor"></a></h2>

<p>Assign-once (read-only) local variable:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">a</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">1</span>
<span class="k">val</span> <span class="py">b</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// `Int` type is inferred</span>
<span class="k">val</span> <span class="py">c</span><span class="p">:</span> <span class="n">Int</span> <span class="c1">// Type required when no initializer is provided</span>
<span class="n">c</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// definite assignment</span></code></pre>

<p>Mutable variable:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="py">x</span> <span class="p">=</span> <span class="m">5</span> <span class="c1">// `Int` type is inferred</span>
<span class="n">x</span> <span class="p">+=</span> <span class="m">1</span></code></pre>

<p>See also <a href="properties.html">Properties And Fields</a>.</p>

<h2 id="using-string-templates">Using string templates<a href="#using-string-templates" class="anchor"></a></h2>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span>

  <span class="n">print</span><span class="p">(</span><span class="s">&quot;First argument: ${args[0]}&quot;</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>See <a href="basic-types.html#string-templates">String templates</a>.</p>

<h2 id="using-conditional-expressions">Using conditional expressions<a href="#using-conditional-expressions" class="anchor"></a></h2>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">max</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">b</span>
<span class="p">}</span></code></pre>

<p>Using <em class="keyword">if</em> as an expression:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">max</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span></code></pre>

<p>See <a href="control-flow.html#if-expression"><em class="keyword">if</em>-expressions</a>.</p>

<h2 id="using-nullable-values-and-checking-for-null-keyword-">Using nullable values and checking for <em class="keyword">null</em><a href="#using-nullable-values-and-checking-for-null-keyword-" class="anchor"></a></h2>

<p>A reference must be explicitly marked as nullable when <em class="keyword">null</em> value is possible.</p>

<p>Return <em class="keyword">null</em> if <code>str</code> does not hold an integer:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">parseInt</span><span class="p">(</span><span class="n">str</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Int</span><span class="p">?</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>Use a function returning nullable value:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Two integers expected&quot;</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="k">val</span> <span class="py">x</span> <span class="p">=</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>
  <span class="k">val</span> <span class="py">y</span> <span class="p">=</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="m">1</span><span class="p">])</span>

  <span class="c1">// Using `x * y` yields error because they may hold nulls.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">y</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// x and y are automatically cast to non-nullable after null check</span>
    <span class="n">print</span><span class="p">(</span><span class="n">x</span> <span class="p">*</span> <span class="n">y</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>or</p>

<pre><code class="code-block _highlighted lang_kotlin">  <span class="c1">// ...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Wrong number format in &#39;${args[0]}&#39;&quot;</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Wrong number format in &#39;${args[1]}&#39;&quot;</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="p">}</span>

  <span class="c1">// x and y are automatically cast to non-nullable after null check</span>
  <span class="n">print</span><span class="p">(</span><span class="n">x</span> <span class="p">*</span> <span class="n">y</span><span class="p">)</span></code></pre>

<p>See <a href="null-safety.html">Null-safety</a>.</p>

<h2 id="using-type-checks-and-automatic-casts">Using type checks and automatic casts<a href="#using-type-checks-and-automatic-casts" class="anchor"></a></h2>

<p>The <em class="keyword">is</em> operator checks if an expression is an instance of a type.
If an immutable local variable or property is checked for a specific type, there’s no need to cast it explicitly:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">getStringLength</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span> <span class="n">Int</span><span class="p">?</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// `obj` is automatically cast to `String` in this branch</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">length</span>
  <span class="p">}</span>

  <span class="c1">// `obj` is still of type `Any` outside of the type-checked branch</span>
  <span class="k">return</span> <span class="k">null</span>
<span class="p">}</span></code></pre>

<p>or</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">getStringLength</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span> <span class="n">Int</span><span class="p">?</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="p">!</span><span class="k">is</span> <span class="n">String</span><span class="p">)</span>
    <span class="k">return</span> <span class="k">null</span>

  <span class="c1">// `obj` is automatically cast to `String` in this branch</span>
  <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">length</span>
<span class="p">}</span></code></pre>

<p>or even</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">getStringLength</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span> <span class="n">Int</span><span class="p">?</span> <span class="p">{</span>
  <span class="c1">// `obj` is automatically cast to `String` on the right-hand side of `&amp;&amp;`</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">String</span> <span class="p">&amp;&amp;</span> <span class="n">obj</span><span class="p">.</span><span class="n">length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">.</span><span class="n">length</span>

  <span class="k">return</span> <span class="k">null</span>
<span class="p">}</span></code></pre>

<p>See <a href="classes.html">Classes</a> and <a href="typecasts.html">Type casts</a>.</p>

<h2 id="using-a-for-loop">Using a <code>for</code> loop<a href="#using-a-for-loop" class="anchor"></a></h2>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">arg</span> <span class="k">in</span> <span class="n">args</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>or</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">args</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span>
  <span class="n">print</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></code></pre>

<p>See <a href="control-flow.html#for-loops">for loop</a>.</p>

<h2 id="using-a-while-loop">Using a <code>while</code> loop<a href="#using-a-while-loop" class="anchor"></a></h2>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="py">i</span> <span class="p">=</span> <span class="m">0</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="p">&lt;</span> <span class="n">args</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
    <span class="n">print</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">++])</span>
<span class="p">}</span></code></pre>

<p>See <a href="control-flow.html#while-loops">while loop</a>.</p>

<h2 id="using-when-expression">Using <code>when</code> expression<a href="#using-when-expression" class="anchor"></a></h2>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">cases</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">when</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
    <span class="m">1</span>          <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;One&quot;</span><span class="p">)</span>
    <span class="s">&quot;Hello&quot;</span>    <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;Greeting&quot;</span><span class="p">)</span>
    <span class="k">is</span> <span class="n">Long</span>    <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;Long&quot;</span><span class="p">)</span>
    <span class="p">!</span><span class="k">is</span> <span class="n">String</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;Not a string&quot;</span><span class="p">)</span>
    <span class="k">else</span>       <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;Unknown&quot;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>See <a href="control-flow.html#when-expression">when expression</a>.</p>

<h2 id="using-ranges">Using ranges<a href="#using-ranges" class="anchor"></a></h2>

<p>Check if a number is within a range using <em class="keyword">in</em> operator:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="n">y</span><span class="p">-</span><span class="m">1</span><span class="p">)</span>
  <span class="n">print</span><span class="p">(</span><span class="s">&quot;OK&quot;</span><span class="p">)</span></code></pre>

<p>Check if a number is out of range:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">!</span><span class="k">in</span> <span class="m">0.</span><span class="p">.</span><span class="n">array</span><span class="p">.</span><span class="n">lastIndex</span><span class="p">)</span>
  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Out&quot;</span><span class="p">)</span></code></pre>

<p>Iterating over a range:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">5</span><span class="p">)</span>
  <span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></code></pre>

<p>See <a href="ranges.html">Ranges</a>.</p>

<h2 id="using-collections">Using collections<a href="#using-collections" class="anchor"></a></h2>

<p>Iterating over a collection:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">name</span> <span class="k">in</span> <span class="n">names</span><span class="p">)</span>
  <span class="n">println</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></code></pre>

<p>Checking if a collection contains an object using <em class="keyword">in</em> operator:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">if</span> <span class="p">(</span><span class="n">text</span> <span class="k">in</span> <span class="n">names</span><span class="p">)</span> <span class="c1">// names.contains(text) is called</span>
  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Yes&quot;</span><span class="p">)</span></code></pre>

<p>Using function literals to filter and map collections:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">names</span> <span class="n">filter</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">startsWith</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span> <span class="p">}</span> <span class="n">sortBy</span> <span class="p">{</span> <span class="n">it</span> <span class="p">}</span> <span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toUpperCase</span><span class="p">()</span> <span class="p">}</span> <span class="n">forEach</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span></code></pre>

<p>See <a href="lambdas.html">Higher-order functions and Lambdas</a>.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/idioms.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="idioms">Idioms<a href="#idioms" class="anchor"></a></h1>

<p>A collection of random and frequently used idioms in Kotlin. If you have a favorite idiom, contribute it. Do a pull request.</p>

<h3 id="creating-dtos-pojospocos">Creating DTO’s (POJO’s/POCO’s)<a href="#creating-dtos-pojospocos" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">data</span> <span class="k">class</span> <span class="nc">Customer</span><span class="p">(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="k">val</span> <span class="py">email</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span></code></pre>

<p>provides a <code>Customer</code> class with the following functionality:</p>

<ul>
  <li>getters (and setters in case of <em class="keyword">var</em>’s) for all properties</li>
  <li><code>equals()</code></li>
  <li><code>hashCode()</code></li>
  <li><code>toString()</code></li>
  <li><code>copy()</code></li>
  <li><code>component1()</code>, <code>component2()</code>, …, for all properties (see <a href="data-classes.html">Data classes</a>)</li>
</ul>

<h3 id="declaring-a-final-local-variable">Declaring a final local variable<a href="#declaring-a-final-local-variable" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">foo</span><span class="p">()</span></code></pre>

<h3 id="default-values-for-function-parameters">Default values for function parameters<a href="#default-values-for-function-parameters" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre>

<h3 id="filtering-a-list">Filtering a list<a href="#filtering-a-list" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">positives</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">x</span> <span class="p">-&gt;</span> <span class="n">x</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">}</span></code></pre>

<p>Or alternatively, even shorter:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">positives</span> <span class="p">=</span> <span class="n">list</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">}</span></code></pre>

<h3 id="string-interpolation">String Interpolation<a href="#string-interpolation" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">println</span><span class="p">(</span><span class="s">&quot;Name $name&quot;</span><span class="p">)</span></code></pre>

<h3 id="instance-checks">Instance Checks<a href="#instance-checks" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">when</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">is</span> <span class="n">Foo</span> <span class="p">-&gt;</span> <span class="p">...</span>
    <span class="k">is</span> <span class="n">Bar</span> <span class="p">-&gt;</span> <span class="p">...</span>
    <span class="k">else</span>   <span class="p">-&gt;</span> <span class="p">...</span>
<span class="p">}</span></code></pre>

<h3 id="traversing-a-maplist-of-pairs">Traversing a map/list of pairs<a href="#traversing-a-maplist-of-pairs" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;$k -&gt; $v&quot;</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p><code>k</code>, <code>v</code> can be called anything.</p>

<h3 id="using-ranges">Using ranges<a href="#using-ranges" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">100</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="m">2.</span><span class="p">.</span><span class="m">10</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre>

<h3 id="read-only-list">Read-only list<a href="#read-only-list" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">)</span></code></pre>

<h3 id="read-only-map">Read-only map<a href="#read-only-map" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">map</span> <span class="p">=</span> <span class="n">mapOf</span><span class="p">(</span><span class="s">&quot;a&quot;</span> <span class="n">to</span> <span class="m">1</span><span class="p">,</span> <span class="s">&quot;b&quot;</span> <span class="n">to</span> <span class="m">2</span><span class="p">,</span> <span class="s">&quot;c&quot;</span> <span class="n">to</span> <span class="m">3</span><span class="p">)</span></code></pre>

<h3 id="accessing-a-map">Accessing a map<a href="#accessing-a-map" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">println</span><span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="s">&quot;key&quot;</span><span class="p">])</span>
<span class="n">map</span><span class="p">[</span><span class="s">&quot;key&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="n">value</span></code></pre>

<h3 id="lazy-property">Lazy property<a href="#lazy-property" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">p</span><span class="p">:</span> <span class="n">String</span> <span class="k">by</span> <span class="n">Delegates</span><span class="p">.</span><span class="n">lazy</span> <span class="p">{</span>
    <span class="c1">// compute the string</span>
<span class="p">}</span></code></pre>

<h3 id="extension-functions">Extension Functions<a href="#extension-functions" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">String</span><span class="p">.</span><span class="n">spaceToCamelCase</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>

<span class="s">&quot;Convert this to camelcase&quot;</span><span class="p">.</span><span class="n">spaceToCamelCase</span><span class="p">()</span></code></pre>

<h3 id="creating-a-singleton">Creating a singleton<a href="#creating-a-singleton" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">object</span> <span class="nc">Resource</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">name</span> <span class="p">=</span> <span class="s">&quot;Name&quot;</span>
<span class="p">}</span></code></pre>

<h3 id="if-not-null-shorthand">If not null shorthand<a href="#if-not-null-shorthand" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">files</span> <span class="p">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">).</span><span class="n">listFiles</span><span class="p">()</span>

<span class="n">println</span><span class="p">(</span><span class="n">files</span><span class="o">?.</span><span class="n">size</span><span class="p">)</span></code></pre>

<h3 id="if-not-null-and-else-shorthand">If not null and else shorthand<a href="#if-not-null-and-else-shorthand" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">files</span> <span class="p">=</span> <span class="n">File</span><span class="p">(</span><span class="s">&quot;Test&quot;</span><span class="p">).</span><span class="n">listFiles</span><span class="p">()</span>

<span class="n">println</span><span class="p">(</span><span class="n">files</span><span class="o">?.</span><span class="n">size</span> <span class="o">?:</span> <span class="s">&quot;empty&quot;</span><span class="p">)</span></code></pre>

<h3 id="executing-a-statement-if-null">Executing a statement if null<a href="#executing-a-statement-if-null" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">data</span> <span class="p">=</span> <span class="p">...</span>
<span class="k">val</span> <span class="py">email</span> <span class="p">=</span> <span class="n">data</span><span class="p">[</span><span class="s">&quot;email&quot;</span><span class="p">]</span> <span class="o">?:</span> <span class="k">throw</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&quot;Email is missing!&quot;</span><span class="p">)</span></code></pre>

<h3 id="execute-if-not-null">Execute if not null<a href="#execute-if-not-null" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">data</span> <span class="p">=</span> <span class="p">...</span>

<span class="n">data</span><span class="o">?.</span><span class="n">let</span> <span class="p">{</span>
    <span class="p">...</span> <span class="c1">// execute this block if not null</span>
<span class="p">}</span></code></pre>

<h3 id="return-on-when-statement">Return on when statement<a href="#return-on-when-statement" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">transform</span><span class="p">(</span><span class="n">color</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">when</span> <span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="p">{</span>
        <span class="s">&quot;Red&quot;</span> <span class="p">-&gt;</span> <span class="m">0</span>
        <span class="s">&quot;Green&quot;</span> <span class="p">-&gt;</span> <span class="m">1</span>
        <span class="s">&quot;Blue&quot;</span> <span class="p">-&gt;</span> <span class="m">2</span>
        <span class="k">else</span> <span class="p">-&gt;</span> <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;Invalid color param value&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>

<h3 id="return-on-try-catch-block">Return on try catch block<a href="#return-on-try-catch-block" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="k">try</span> <span class="p">{</span>
        <span class="n">count</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">ArithmeticException</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">throw</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// Working with result</span>
<span class="p">}</span></code></pre>

<h3 id="return-on-if-statement">Return on if statement<a href="#return-on-if-statement" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">(</span><span class="n">param</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">param</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="s">&quot;one&quot;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">param</span> <span class="p">==</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="s">&quot;two&quot;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="s">&quot;three&quot;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>

<h3 id="single-expression-functions">Single-expression functions<a href="#single-expression-functions" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">theAnswer</span><span class="p">()</span> <span class="p">=</span> <span class="m">42</span></code></pre>

<p>This is equivalent to</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">theAnswer</span><span class="p">():</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="m">42</span>
<span class="p">}</span></code></pre>

<p>This can be effectively combined with other idioms, leading to shorter code. E.g. with the <em class="keyword">when</em>-expression:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">transform</span><span class="p">(</span><span class="n">color</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Int</span> <span class="p">=</span> <span class="k">when</span> <span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="p">{</span>
    <span class="s">&quot;Red&quot;</span> <span class="p">-&gt;</span> <span class="m">0</span>
    <span class="s">&quot;Green&quot;</span> <span class="p">-&gt;</span> <span class="m">1</span>
    <span class="s">&quot;Blue&quot;</span> <span class="p">-&gt;</span> <span class="m">2</span>
    <span class="k">else</span> <span class="p">-&gt;</span> <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;Invalid color param value&quot;</span><span class="p">)</span>
<span class="p">}</span></code></pre>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/coding-conventions.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="coding-conventions">Coding Conventions<a href="#coding-conventions" class="anchor"></a></h1>

<p>This page contains the current coding style for the Kotlin language.</p>

<h2 id="naming-style">Naming Style<a href="#naming-style" class="anchor"></a></h2>
<p>If in doubt default to the Java Coding Conventions such as:</p>

<ul>
  <li>use of camelCase for names (and avoid underscore in names)</li>
  <li>types start with upper case</li>
  <li>methods and properties start with lower case</li>
  <li>use 4 space indentation</li>
  <li>public functions should have documentation such that it appears in Kotlin Doc</li>
</ul>

<p>Kotlin does not have fields as a primary concept in the language – it only has properties.
Avoid the use of prefixes on properties, such as _ or m_ or other kinds of notation.
If you need access to a backing field of a property, use the $ prefix: <code>$foo</code> to refer to a field behind property <code>foo</code>;
never create a private property and call it <code>_foo</code></p>

<h2 id="colon">Colon<a href="#colon" class="anchor"></a></h2>

<p>There is a space before colon where colon separates type and supertype and there’s no space where colon separates instance and type:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">interface</span> <span class="n">Foo</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span> <span class="p">:</span> <span class="n">Any</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">Bar</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">foo</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">T</span>
<span class="p">}</span></code></pre>

<h2 id="unit">Unit<a href="#unit" class="anchor"></a></h2>
<p>If a function returns Unit, the return type should be omitted:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// &quot;: Unit&quot; is omitted here</span>

<span class="p">}</span></code></pre>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/basic-types.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="basic-types">Basic Types<a href="#basic-types" class="anchor"></a></h1>

<p>In Kotlin, everything is an object in the sense that we can call member functions and properties on any variable. Some types are built-in, because their implementation is optimized, but to the user they look like ordinary classes. In this section we describe most of these types: numbers, characters, booleans and arrays.</p>

<h2 id="numbers">Numbers<a href="#numbers" class="anchor"></a></h2>

<p>Kotlin handles numbers in a way close to Java, but not exactly the same. For example, there are no implicit widening conversions for numbers, and literals are slightly different in some cases.</p>

<p>Kotlin provides the following built-in types representing numbers (this is close to Java):</p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>Bitwidth</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Double</td>
      <td>64</td>
    </tr>
    <tr>
      <td>Float</td>
      <td>32</td>
    </tr>
    <tr>
      <td>Long</td>
      <td>64</td>
    </tr>
    <tr>
      <td>Int</td>
      <td>32</td>
    </tr>
    <tr>
      <td>Short</td>
      <td>16</td>
    </tr>
    <tr>
      <td>Byte</td>
      <td>8</td>
    </tr>
  </tbody>
</table>

<p>Note that characters are not numbers in Kotlin.</p>

<h3 id="literal-constants">Literal Constants<a href="#literal-constants" class="anchor"></a></h3>

<p>There are the following kinds of literal constants for integral values:</p>

<ul>
  <li>Decimals: <code>123</code>
    <ul>
      <li>Longs are tagged by a capital <code>L</code>: <code>123L</code></li>
    </ul>
  </li>
  <li>Hexadecimals: <code>0x0F</code></li>
  <li>Binaries: <code>0b00001011</code></li>
</ul>

<p>NOTE: Octal literals are not supported.</p>

<p>Kotlin also supports a conventional notation for floating-point numbers:</p>

<ul>
  <li>Doubles by default: <code>123.5</code>, <code>123.5e10</code></li>
  <li>Floats are tagged by <code>f</code> or <code>F</code>: <code>123.5f</code> </li>
</ul>

<h3 id="representation">Representation<a href="#representation" class="anchor"></a></h3>

<p>On the Java platform, numbers are physically stored as JVM primitive types, unless we need a nullable number reference (e.g. <code>Int?</code>) or generics are involved. 
In the latter cases numbers are boxed.</p>

<p>Note that boxing of numbers does not preserve identity:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">a</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">10000</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="n">identityEquals</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// Prints &#39;true&#39;</span>
<span class="k">val</span> <span class="py">boxedA</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span>
<span class="k">val</span> <span class="py">anotherBoxedA</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span>
<span class="n">print</span><span class="p">(</span><span class="n">boxedA</span> <span class="n">identityEquals</span> <span class="n">anotherBoxedA</span><span class="p">)</span> <span class="c1">// !!!Prints &#39;false&#39;!!!</span></code></pre>

<p>On the other hand, it preserves equality:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">a</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">10000</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">a</span><span class="p">)</span> <span class="c1">// Prints &#39;true&#39;</span>
<span class="k">val</span> <span class="py">boxedA</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span>
<span class="k">val</span> <span class="py">anotherBoxedA</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span>
<span class="n">print</span><span class="p">(</span><span class="n">boxedA</span> <span class="p">==</span> <span class="n">anotherBoxedA</span><span class="p">)</span> <span class="c1">// Prints &#39;true&#39;</span></code></pre>

<h3 id="explicit-conversions">Explicit Conversions<a href="#explicit-conversions" class="anchor"></a></h3>

<p>Due to different representations, smaller types are not subtypes of bigger ones.
If they were, we would have troubles of the following sort</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// Hypothetical code, does not actually compile:</span>
<span class="k">val</span> <span class="py">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// A boxed Int (java.lang.Integer)</span>
<span class="k">val</span> <span class="py">b</span><span class="p">:</span> <span class="n">Long</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span> <span class="c1">// implicit conversion yields a boxed Long (java.lang.Long)</span>
<span class="n">print</span><span class="p">(</span><span class="n">a</span> <span class="p">==</span> <span class="n">b</span><span class="p">)</span> <span class="c1">// Surprise! This prints &quot;false&quot; as Long&#39;s equals() check for other part to be Long as well</span></code></pre>

<p>So not only identity, but even equality would have been lost silently all over the place.</p>

<p>As a consequence, smaller types are NOT implicitly converted to bigger types.
This means that we cannot assign a value of type <code>Byte</code> to an <code>Int</code> variable without an explicit conversion</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">b</span><span class="p">:</span> <span class="n">Byte</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// OK, literals are checked statically</span>
<span class="k">val</span> <span class="py">i</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">b</span> <span class="c1">// ERROR</span></code></pre>

<p>We can use explicit conversions to widen numbers</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">i</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span> <span class="c1">// OK: explicitly widened</span></code></pre>

<p>Every number type supports the following conversions:</p>

<ul>
  <li><code>toByte(): Byte</code></li>
  <li><code>toShort(): Short</code></li>
  <li><code>toInt(): Int</code></li>
  <li><code>toLong(): Long</code></li>
  <li><code>toFloat(): Float</code></li>
  <li><code>toDouble(): Double</code></li>
  <li><code>toChar(): Char</code></li>
</ul>

<p>Absence of implicit conversions is rarely noticeable because we can use literals almost freely cause the type is inferred from the context, and arithmetical operations are overloaded for appropriate conversions, for example</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="m">1.</span><span class="n">toLong</span><span class="p">()</span> <span class="p">+</span> <span class="m">3</span> <span class="c1">// Long + Int =&gt; Long</span></code></pre>

<h3 id="operations">Operations<a href="#operations" class="anchor"></a></h3>

<p>Kotlin supports the standard set of arithmetical operations over numbers, which are declared as members of appropriate classes (but the compiler optimizes the calls down to the corresponding instructions).
See <a href="operator-overloading.html">Operator overloading</a>.</p>

<p>As of bitwise operations, there’re no special characters for them, but just named functions that can be called in infix form, for example:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">x</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span> <span class="n">shl</span> <span class="m">2</span><span class="p">)</span> <span class="n">and</span> <span class="m">0</span><span class="n">x000FF000</span></code></pre>

<p>Here is the complete list of bitwise operations (available for <code>Int</code> and <code>Long</code> only):</p>

<ul>
  <li><code>shl(bits)</code> – signed shift left (Java’s <code>&lt;&lt;</code>)</li>
  <li><code>shr(bits)</code> – signed shift right (Java’s <code>&gt;&gt;</code>)</li>
  <li><code>ushr(bits)</code> – unsigned shift right (Java’s <code>&gt;&gt;&gt;</code>)</li>
  <li><code>and(bits)</code> – bitwise and</li>
  <li><code>or(bits)</code> – bitwise or</li>
  <li><code>xor(bits)</code> – bitwise xor</li>
  <li><code>inv()</code> – bitwise inversion</li>
</ul>

<h2 id="characters">Characters<a href="#characters" class="anchor"></a></h2>

<p>Characters are represented by the type <code>Char</code>. They can not be treated directly as numbers</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">check</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Char</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// ERROR: incompatible types</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Character literals go in single quotes: <code>'1'</code>, <code>'\n'</code>, <code>'\uFF00'</code>.
We can explicitly convert a character to an <code>Int</code> number</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">decimalDigitValue</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="n">Char</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="p">!</span><span class="k">in</span> <span class="sc">&#39;0&#39;</span><span class="p">..</span><span class="sc">&#39;9&#39;</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;Out of range&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">c</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span> <span class="p">-</span> <span class="sc">&#39;0&#39;</span><span class="p">.</span><span class="n">toInt</span><span class="p">()</span> <span class="c1">// Explicit conversions to numbers</span>
<span class="p">}</span></code></pre>

<p>Like numbers, characters are boxed when a nullable reference is needed. Identity is not preserved by the boxing operation.</p>

<h2 id="booleans">Booleans<a href="#booleans" class="anchor"></a></h2>

<p>The type <code>Boolean</code> represents booleans, and has two values: <em class="keyword">true</em> and <em class="keyword">false</em>.</p>

<p>Booleans are boxed if a nullable reference is needed.</p>

<p>Built-in operations on booleans include</p>

<ul>
  <li><code>||</code> – lazy disjunction</li>
  <li><code>&amp;&amp;</code> – lazy conjunction</li>
</ul>

<h2 id="arrays">Arrays<a href="#arrays" class="anchor"></a></h2>

<p>Arrays in Kotlin are represented by the <code>Array</code> class, that has <code>get</code> and <code>set</code> functions (that turn into <code>[]</code> by operator overloading conventions), and <code>size</code>, along with a few other useful member functions:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">private</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">size</span><span class="p">():</span> <span class="n">Int</span>
  <span class="k">fun</span> <span class="nf">get</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">T</span>
  <span class="k">fun</span> <span class="nf">set</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Unit</span>

  <span class="k">fun</span> <span class="nf">iterator</span><span class="p">():</span> <span class="n">Iterator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>To create an array, we can use a library function <code>arrayOf()</code> and pass the item values to it, so that <code>arrayOf(1, 2, 3)</code> creates an array [1, 2, 3].
Alternatively, the <code>arrayOfNulls()</code> library function can be used to create an array of a given size filled with null elements.</p>

<p>Another option is to use a factory function that takes the array size and the function that can return the initial value
of each array element given its index:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// Creates an Array&lt;String&gt; with values [&quot;0&quot;, &quot;1&quot;, &quot;4&quot;, &quot;9&quot;, &quot;16&quot;]</span>
<span class="k">val</span> <span class="py">asc</span> <span class="p">=</span> <span class="n">Array</span><span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="p">{</span><span class="n">i</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="p">*</span> <span class="n">i</span><span class="p">).</span><span class="n">toString</span><span class="p">()})</span></code></pre>

<p>As we said above, the <code>[]</code> operation stands for calls to member functions <code>get()</code> and <code>set()</code>.</p>

<p>Note: unlike Java, arrays in Kotlin are invariant. This means that Kotlin does not let us assign an <code>Array&lt;String&gt;</code>
to an <code>Array&lt;Any&gt;</code>, which prevents a possible runtime failure (but you can use <code>Array&lt;out Any&gt;</code>, 
see <a href="generics.html#type-projections">Type Projections</a>).</p>

<p>Kotlin also has specialized classes to represent arrays of primitive types without boxing overhead: ByteArray,
ShortArray, IntArray and so on. These classes have no inheritance relation to the <code>Array</code> class, but they
have the same set of methods and properties. Each of them also has a corresponding factory function:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">x</span><span class="p">:</span> <span class="n">IntArray</span> <span class="p">=</span> <span class="n">intArray</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
<span class="n">x</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">x</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">+</span> <span class="n">x</span><span class="p">[</span><span class="m">2</span><span class="p">]</span></code></pre>

<h2 id="strings">Strings<a href="#strings" class="anchor"></a></h2>

<p>Strings are represented by the type <code>String</code>. Strings are immutable.
Elements of a string are characters that can be accessed by the indexing operation: <code>s[i]</code>.
A string can be iterated over with a <em class="keyword">for</em>-loop:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="k">in</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<h3 id="string-literals">String Literals<a href="#string-literals" class="anchor"></a></h3>

<p>Kotlin has two types of string literals: escaped strings that may have escaped characters in them and raw strings that can contain newlines and arbitrary text. An escaped string is very much like a Java string:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">s</span> <span class="p">=</span> <span class="s">&quot;Hello, world!\n&quot;</span></code></pre>

<p>Escaping is done in the conventional way, with a backslash.</p>

<p>A raw string is delimited by a triple quote (<code>"""</code>), contains no escaping and can contain newlines and any other characters:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">text</span> <span class="p">=</span> <span class="s">&quot;&quot;&quot;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="k">in</span> <span class="s">&quot;foo&quot;</span><span class="p">)</span>
    <span class="n">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="s">&quot;&quot;&quot;</span></code></pre>

<h3 id="templates">Templates<a href="#templates" class="anchor"></a></h3>

<p>Strings may contain template expressions, i.e. pieces of code that are evaluated and whose results are concatenated into the string. A template expression starts with a dollar sign ($) and consists of either a simple name:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">i</span> <span class="p">=</span> <span class="m">10</span>
<span class="k">val</span> <span class="py">s</span> <span class="p">=</span> <span class="s">&quot;i = $i&quot;</span> <span class="c1">// evaluates to &quot;i = 10&quot;</span></code></pre>

<p>or an arbitrary expression in curly braces:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">s</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span>
<span class="k">val</span> <span class="py">str</span> <span class="p">=</span> <span class="s">&quot;$s.length is ${s.length}&quot;</span> <span class="c1">// evaluates to &quot;abc.length is 3&quot;</span></code></pre>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/packages.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="packages">Packages<a href="#packages" class="anchor"></a></h1>

<p>A source file may start with a package declaration:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">package</span> <span class="nn">foo.bar</span>

<span class="k">fun</span> <span class="nf">baz</span><span class="p">()</span> <span class="p">{}</span>

<span class="k">class</span> <span class="nc">Goo</span> <span class="p">{}</span>

<span class="c1">// ...</span></code></pre>

<p>All the contents (such as classes and functions) of the source file are contained by the package declared.
So, in the example above, the full name of <code>baz()</code> is <code>foo.bar.baz</code>, and the full name of <code>Goo</code> is <code>foo.bar.Goo</code>. </p>

<p>If the package is not specified, the contents of such a file belong to “default” package that has no name.</p>

<h2 id="imports">Imports<a href="#imports" class="anchor"></a></h2>

<p>Apart from the default imports declared by the module, each file may contain its own import directives.
Syntax for imports is described in the <a href="grammar.html#imports">grammar</a>.</p>

<p>We can import either a single name, e.g.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">import</span> <span class="nn">foo.Bar</span> <span class="c1">// Bar is now accessible without qualification</span></code></pre>

<p>or all the accessible contents of a scope (package, class, object etc):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">import</span> <span class="nn">foo.*</span> <span class="c1">// everything in &#39;foo&#39; becomes accessible</span></code></pre>

<p>If there is a name clash, we can disambiguate by using <em class="keyword">as</em> keyword to locally rename the clashing entity:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">import</span> <span class="nn">foo.Bar</span> <span class="c1">// Bar is accessible</span>
<span class="k">import</span> <span class="nn">bar.Bar</span> <span class="k">as</span> <span class="n">bBar</span> <span class="c1">// bBar stands for &#39;bar.Bar&#39;</span></code></pre>

<h2 id="visibility-and-package-nesting">Visibility and Package Nesting<a href="#visibility-and-package-nesting" class="anchor"></a></h2>

<p>If a top-level declaration is marked <em class="keyword">private</em>, it is private to the package it’s declared in (see <a href="visibility-modifiers.html">Visibility Modifiers</a>).
Since packages really nest in Kotlin, i.e. package <code>foo.bar</code> is considered a member of <code>foo</code>, if something is <em class="keyword">private</em> in a package, 
it is visible to all its subpackages.</p>

<p>Note that members of outer packages are <strong>not</strong> imported by default, i.e. in a file in package <code>foo.bar</code> we can’t access
members of <code>foo</code> without importing them.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/control-flow.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="control-flow">Control Flow<a href="#control-flow" class="anchor"></a></h1>

<h2 id="if-expression">If Expression<a href="#if-expression" class="anchor"></a></h2>

<p>In Kotlin, <em class="keyword">if</em> is an expression, i.e. it returns a value.
Therefore there is no ternary operator (condition ? then : else), because ordinary <em class="keyword">if</em> works fine in this role.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// Traditional usage </span>
<span class="k">var</span> <span class="py">max</span> <span class="p">=</span> <span class="n">a</span> 
<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&lt;</span> <span class="n">b</span><span class="p">)</span> 
  <span class="n">max</span> <span class="p">=</span> <span class="n">b</span> 
 
<span class="c1">// With else </span>
<span class="k">var</span> <span class="py">max</span><span class="p">:</span> <span class="n">Int</span>
<span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> 
  <span class="n">max</span> <span class="p">=</span> <span class="n">a</span> 
<span class="k">else</span> 
  <span class="n">max</span> <span class="p">=</span> <span class="n">b</span> 
 
<span class="c1">// As expression </span>
<span class="k">val</span> <span class="py">max</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span></code></pre>

<p><em class="keyword">if</em> branches can be blocks, and the last expression is the value of a block:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">max</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> 
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Choose a&quot;</span><span class="p">)</span> 
    <span class="n">a</span> 
  <span class="p">}</span> 
  <span class="k">else</span> <span class="p">{</span> 
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Choose b&quot;</span><span class="p">)</span> 
    <span class="n">b</span> 
  <span class="p">}</span></code></pre>

<p>When <em class="keyword">if</em> has only one branch, or one of its branches results in <code>Unit</code>, its type is <code>Unit</code>.</p>

<p>See the <a href="grammar.html#if">grammar for <em class="keyword">if</em></a>.</p>

<h2 id="when-expression">When Expression<a href="#when-expression" class="anchor"></a></h2>

<p><em class="keyword">when</em> replaces the switch operator of C-like languages. In the simplest form it looks like this</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">when</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="m">1</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;x == 1&quot;</span><span class="p">)</span>
  <span class="m">2</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;x == 2&quot;</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="c1">// Note the block</span>
    <span class="n">print</span><span class="p">(</span><span class="s">&quot;x is neither 1 nor 2&quot;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p><em class="keyword">when</em> matches its argument against all branches consequently until some branch condition is satisfied.
<em class="keyword">when</em> can be used either as an expression or as a statement. If it is used as an expression, the value
of the satisfied branch becomes the value of the overall expression. If it is used as a statement, the values of
individual branches are ignored. (Just like with <em class="keyword">if</em>, each branch can be a block, and its value
is the value of the last expression in the block.)</p>

<p>The <em class="keyword">else</em> branch is evaluated if none of the other branch conditions are satisfied.
If <em class="keyword">when</em> is used as an expression, the <em class="keyword">else</em> branch is mandatory,
unless the compiler can prove that all possible cases are covered with branch conditions.</p>

<p>If many cases should be handled in the same way, the branch conditions may be combined with a comma:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">when</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="m">0</span><span class="p">,</span> <span class="m">1</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;x == 0 or x == 1&quot;</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;otherwise&quot;</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>We can use arbitrary expressions (not only constants) as branch conditions</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">when</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">parseInt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;s encodes x&quot;</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;s does not encode x&quot;</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>We can also check a value for being <em class="keyword">in</em> or <em class="keyword">!in</em> a <a href="ranges.html">range</a> or a collection:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">when</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">10</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;x is in the range&quot;</span><span class="p">)</span>
  <span class="k">in</span> <span class="n">validNumbers</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;x is valid&quot;</span><span class="p">)</span>
  <span class="p">!</span><span class="k">in</span> <span class="m">10.</span><span class="p">.</span><span class="m">20</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;x is outside the range&quot;</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;none of the above&quot;</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>Another possibility is to check that a value <em class="keyword">is</em> or <em class="keyword">!is</em> of a particular type. Note that,
due to <a href="typecasts.html#smart-casts">smart casts</a>, you can access the methods and properties of the type without
any extra checks.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">hasPrefix</span> <span class="p">=</span> <span class="k">when</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">is</span> <span class="n">String</span> <span class="p">-&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">startsWith</span><span class="p">(</span><span class="s">&quot;prefix&quot;</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">-&gt;</span> <span class="k">false</span>
<span class="p">}</span></code></pre>

<p><em class="keyword">when</em> can also be used as a replacement for an <em class="keyword">if</em>-<em class="keyword">else</em> <em class="keyword">if</em> chain.
If no argument is supplied, the branch conditions are simply boolean expressions, and a branch is executed when its condition is true:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">when</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">.</span><span class="n">isOdd</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;x is odd&quot;</span><span class="p">)</span>
  <span class="n">x</span><span class="p">.</span><span class="n">isEven</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;x is even&quot;</span><span class="p">)</span>
  <span class="k">else</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;x is funny&quot;</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>See the <a href="grammar.html#when">grammar for <em class="keyword">when</em></a>.</p>

<h2 id="for-loops">For Loops<a href="#for-loops" class="anchor"></a></h2>

<p><em class="keyword">for</em> loop iterates through anything that provides an iterator. The syntax is as follows:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">item</span> <span class="k">in</span> <span class="n">collection</span><span class="p">)</span>
  <span class="n">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span></code></pre>

<p>The body can be a block.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Int</span> <span class="k">in</span> <span class="n">ints</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>As mentioned before, <em class="keyword">for</em> iterates through anything that provides an iterator, i.e.</p>

<ul>
  <li>has an instance- or extension-function <code>iterator()</code>, whose return type
    <ul>
      <li>has an instance- or extension-function <code>next()</code>, and</li>
      <li>has an instance- or extension-function <code>hasNext()</code> that returns <code>Boolean</code>.</li>
    </ul>
  </li>
</ul>

<p>If you want to iterate through an array or a list with an index, you can do it this way:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">array</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span>
  <span class="n">print</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span></code></pre>

<p>Note that this “iteration through a range” is compiled down to optimal implementation with no extra objects created.</p>

<p>See the <a href="grammar.html#for">grammar for <em class="keyword">for</em></a>.</p>

<h2 id="while-loops">While Loops<a href="#while-loops" class="anchor"></a></h2>

<p><em class="keyword">while</em> and <em class="keyword">do</em>..<em class="keyword">while</em> work as usual</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">--</span>
<span class="p">}</span>

<span class="k">do</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">y</span> <span class="p">=</span> <span class="n">retrieveData</span><span class="p">()</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">y</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="c1">// y is visible here!</span></code></pre>

<p>See the <a href="grammar.html#while">grammar for <em class="keyword">while</em></a>.</p>

<h2 id="break-and-continue-in-loops">Break and continue in loops<a href="#break-and-continue-in-loops" class="anchor"></a></h2>

<p>Kotlin supports traditional <em class="keyword">break</em> and <em class="keyword">continue</em> operators in loops. See <a href="returns.html">Returns and jumps</a>.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/returns.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="returns-and-jumps">Returns and Jumps<a href="#returns-and-jumps" class="anchor"></a></h1>

<p>Kotlin has three structural jump operators</p>

<ul>
  <li><em class="keyword">return</em>. By default returns from the nearest enclosing function or <a href="lambdas.html#function-expressions">function expression</a>.</li>
  <li><em class="keyword">break</em>. Terminates the nearest enclosing loop.</li>
  <li><em class="keyword">continue</em>. Proceeds to the next step of the nearest enclosing loop.</li>
</ul>

<h2 id="break-and-continue-labels">Break and Continue Labels<a href="#break-and-continue-labels" class="anchor"></a></h2>

<p>Any expression in Kotlin may be marked with a <em class="keyword">label</em>.
Labels have the form of an identifier followed by the <code>@</code> sign, for example: <code>abc@</code>, <code>fooBar@</code> are valid labels (see the <a href="grammar.html#label">grammar</a>).
To label an expression, we just put a label in front of it</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">loop</span><span class="err">@</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">100</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>Now, we can qualify a <em class="keyword">break</em> or a <em class="keyword">continue</em> with a label:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">loop</span><span class="err">@</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">100</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">100</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(...)</span>
      <span class="k">break</span><span class="n">@loop</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>A <em class="keyword">break</em> qualified with a label jumps to the execution point right after the loop marked with that label.
A <em class="keyword">continue</em> proceeds to the next iteration of that loop.</p>

<h2 id="return-at-labels">Return at Labels<a href="#return-at-labels" class="anchor"></a></h2>

<p>With function literals, local functions and object expression, functions can be nested in Kotlin. 
Qualified <em class="keyword">return</em>s allow us to return from an outer function. 
The most important use case is returning from a function literal. Recall that when we write this:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ints</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span>
    <span class="n">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>The <em class="keyword">return</em>-expression returns from the nearest enclosing function, i.e. <code>foo</code>.
(Note that such non-local returns are supported only for function literals passed to <a href="inline-functions.html">inline-functions</a>.)
If we need to return from a function literal, we have to label it and qualify the <em class="keyword">return</em>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ints</span><span class="p">.</span><span class="n">forEach</span> <span class="n">lit</span><span class="err">@</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span><span class="n">@lit</span>
    <span class="n">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Now, it returns only from the function literal. Oftentimes it is more convenient to use implicits labels:
such a label has the same name as the function to which the lambda is passed.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ints</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span><span class="n">@forEach</span>
    <span class="n">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Alternatively, we can replace the function literal with a <a href="lambdas.html#function-expressions">function expression</a>.
A <em class="keyword">return</em> statement in a function expression will return from the function expression itself.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ints</span><span class="p">.</span><span class="n">forEach</span><span class="p">(</span><span class="k">fun</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span>
    <span class="n">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span></code></pre>

<p>When returning a value, the parser gives preference to the qualified return, i.e.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">return</span><span class="n">@a</span> <span class="m">1</span></code></pre>

<p>means “return <code>1</code> at label <code>@a</code>” and not “return a labeled expression <code>(@a 1)</code>”.</p>

<p>Named functions automatically define labels:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">outer</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">inner</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span><span class="n">@outer</span> <span class="c1">// the label @outer was defined automatically</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/classes.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="classes-and-inheritance">Classes and Inheritance<a href="#classes-and-inheritance" class="anchor"></a></h1>

<h2 id="classes">Classes<a href="#classes" class="anchor"></a></h2>

<p>Classes in Kotlin are declared using the keyword <em class="keyword">class</em>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Invoice</span> <span class="p">{</span>
<span class="p">}</span></code></pre>

<p>The class declaration consists of the class name, the class header (specifying its type parameters, the primary
constructor etc.) and the class body, surrounded by curly braces. Both the header and the body are optional;
if the class has no body, curly braces can be omitted.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Empty</span></code></pre>

<h3 id="constructors">Constructors<a href="#constructors" class="anchor"></a></h3>

<p>A class in Kotlin can have a <strong>primary constructor</strong> and one or more <strong>secondary constructors</strong>. The primary
constructor is part of the class header: it goes after the class name (and optional type parameters).</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Person</span> <span class="n">constructor</span><span class="p">(</span><span class="n">firstName</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span></code></pre>

<p>If the primary constructor does not have any annotations or visibility modifiers, the <em class="keyword">constructor</em>
keyword can be omitted:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="n">firstName</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span></code></pre>

<p>The primary constructor cannot contain any code. Initialization code can be placed
in <strong>initializer blocks</strong>, which are prefixed with the <em class="keyword">init</em>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Customer</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">init</span> <span class="p">{</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">&quot;Customer initialized with value ${name}&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Note that parameters of the primary constructor can be used in the initializer blocks. They can also be used in
property initializers declared in the class body:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Customer</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">customerKey</span> <span class="p">=</span> <span class="n">name</span><span class="p">.</span><span class="n">toUpperCase</span><span class="p">()</span>
<span class="p">}</span></code></pre>

<p>In fact, for declaring properties and initializing them from the primary constructor, Kotlin has a concise syntax:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="k">val</span> <span class="py">firstName</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="k">val</span> <span class="py">lastName</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="k">var</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>Much the same way as regular properties, the properties declared in the primary constructor can be
mutable (<em class="keyword">var</em>) or read-only (<em class="keyword">val</em>).</p>

<p>If the constructor has annotations or visibility modifiers, the <em class="keyword">constructor</em> keyword is required, and
the modifiers go before it:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Customer</span> <span class="k">public</span> <span class="n">inject</span> <span class="n">constructor</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre>

<p>For more details, see <a href="visibility-modifiers.html#constructors">Visibility Modifiers</a>.</p>

<h4 id="secondary-constructors">Secondary Constructors</h4>

<p>The class can also declare <strong>secondary constructors</strong>, which are prefixed with <em class="keyword">constructor</em>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
    <span class="n">constructor</span><span class="p">(</span><span class="n">parent</span><span class="p">:</span> <span class="n">Person</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">parent</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>If the class has a primary constructor, each secondary constructor needs to delegate to the primary constructor, either
directly or indirectly through another secondary constructor(s). Delegation to another constructor of the same class
is done using the <em class="keyword">this</em> keyword:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">constructor</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">parent</span><span class="p">:</span> <span class="n">Person</span><span class="p">)</span> <span class="p">:</span> <span class="k">this</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">parent</span><span class="p">.</span><span class="n">children</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>If a non-abstract class does not declare any constructors (primary or secondary), it will have a generated primary
constructor with no arguments. The visibility of the constructor will be public. If you do not want your class
to have a public constructor, you need to declare an empty primary constructor with non-default visibility:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">DontCreateMe</span> <span class="k">private</span> <span class="n">constructor</span> <span class="p">()</span> <span class="p">{</span>
<span class="p">}</span></code></pre>

<blockquote class="info">
  <p><strong>NOTE</strong>: On the JVM, if all of the parameters of the primary constructor have default values, the compiler will
generate an additional parameterless constructor which will use the default values. This makes it easier to use
Kotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors.</p>

  <pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Customer</span><span class="p">(</span><span class="k">val</span> <span class="py">customerName</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span></code></pre>
</blockquote>

<h3 id="creating-instances-of-classes">Creating instances of classes<a href="#creating-instances-of-classes" class="anchor"></a></h3>

<p>To create an instance of a class, we call the constructor as if it were a regular function:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">invoice</span> <span class="p">=</span> <span class="n">Invoice</span><span class="p">()</span>

<span class="k">val</span> <span class="py">customer</span> <span class="p">=</span> <span class="n">Customer</span><span class="p">(</span><span class="s">&quot;Joe Smith&quot;</span><span class="p">)</span></code></pre>

<p>Note that Kotlin does not have a <em class="keyword">new</em> keyword.</p>

<h3 id="class-members">Class Members<a href="#class-members" class="anchor"></a></h3>

<p>Classes can contain</p>

<ul>
  <li>Constructors and initializer blocks</li>
  <li><a href="functions.html">Functions</a></li>
  <li><a href="properties.html">Properties</a></li>
  <li><a href="nested-classes.html">Nested and Inner Classes</a></li>
  <li><a href="object-declarations.html">Object Declarations</a></li>
</ul>

<h2 id="inheritance">Inheritance<a href="#inheritance" class="anchor"></a></h2>

<p>All classes in Kotlin have a common superclass <code>Any</code>, that is a default super for a class with no supertypes declared:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Example</span> <span class="c1">// Implicitly inherits from Any</span></code></pre>

<p><code>Any</code> is not <code>java.lang.Object</code>; in particular, it does not have any members other than <code>equals()</code>, <code>hashCode()</code> and <code>toString()</code>.
Please consult the <a href="java-interop.html#object-methods">Java interoperability</a> section for more details.</p>

<p>To declare an explicit supertype, we place the type after a colon in the class header:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">open</span> <span class="k">class</span> <span class="nc">Base</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Base</span><span class="p">(</span><span class="n">p</span><span class="p">)</span></code></pre>

<p>If the class has a primary constructor, the base type can (and must) be initialized right there,
using the parameters of the primary constructor.</p>

<p>If the class has no primary constructor, then each secondary constructor has to initialize the base type
using the <em class="keyword">super</em> keyword, or to delegate to another constructor which does that.
Note that in this case different secondary constructors can call different constructors of the base type:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">MyView</span> <span class="p">:</span> <span class="n">View</span> <span class="p">{</span>
    <span class="n">constructor</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">)</span> <span class="p">:</span> <span class="k">super</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">constructor</span><span class="p">(</span><span class="n">ctx</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">attrs</span><span class="p">:</span> <span class="n">AttributeSet</span><span class="p">)</span> <span class="p">:</span> <span class="k">super</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">attrs</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>The <em class="keyword">open</em> annotation on a class is the opposite of Java’s <em class="keyword">final</em>: it allows others
to inherit from this class. By default, all classes in Kotlin are final, which
corresponds to <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a>,
Item 17: <em>Design and document for inheritance or else prohibit it</em>.</p>

<h3 id="overriding-members">Overriding Members<a href="#overriding-members" class="anchor"></a></h3>

<p>As we mentioned before, we stick to making things explicit in Kotlin. And unlike Java, Kotlin requires explicit
annotations for overridable members (we call them <em>open</em>) and for overrides:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">open</span> <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
  <span class="k">open</span> <span class="k">fun</span> <span class="nf">v</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">fun</span> <span class="nf">nv</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Derived</span><span class="p">()</span> <span class="p">:</span> <span class="n">Base</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">v</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span></code></pre>

<p>The <em class="keyword">override</em> annotation is required for <code>Derived.v()</code>. If it were missing, the compiler would complain.
If there is no <em class="keyword">open</em> annotation on a function, like <code>Base.nv()</code>, declaring a method with the same signature in a subclass is illegal,
either with <em class="keyword">override</em> or without it. In a final class (e.g. a class with no <em class="keyword">open</em> annotation), open members are prohibited.</p>

<p>A member marked <em class="keyword">override</em> is itself open, i.e. it may be overridden in subclasses. If you want to prohibit re-overriding, use <em class="keyword">final</em>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">open</span> <span class="k">class</span> <span class="nc">AnotherDerived</span><span class="p">()</span> <span class="p">:</span> <span class="n">Base</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">final</span> <span class="k">override</span> <span class="k">fun</span> <span class="nf">v</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span></code></pre>

<h4 id="wait-how-will-i-hack-my-libraries-now">Wait! How will I hack my libraries now?!</h4>

<p>One issue with our approach to overriding (classes and members final by default) is that it would be difficult to subclass something inside the libraries you use to override some method that was not intended for overriding by the library designer, and introduce some nasty hack there.</p>

<p>We think that this is not a disadvantage, for the following reasons:</p>

<ul>
  <li>Best practices say that you should not allow these hacks anyway</li>
  <li>People successfully use other languages (C++, C#) that have similar approach</li>
  <li>If people really want to hack, there still are ways: you can always write your hack in Java and call it from Kotlin (<em>see <a href="java-interop.html">Java Interop</a></em>), and Aspect frameworks always work for these purposes</li>
</ul>

<h3 id="overriding-rules">Overriding Rules<a href="#overriding-rules" class="anchor"></a></h3>

<p>In Kotlin, implementation inheritance is regulated by the following rule: if a class inherits many implementations of the same member from its immediate superclasses,
it must override this member and provide its own implementation (perhaps, using one of the inherited ones).
To denote the supertype from which the inherited implementation is taken, we use <em class="keyword">super</em> qualified by the supertype name in angle brackets, e.g. <code>super&lt;Base&gt;</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">open</span> <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">open</span> <span class="k">fun</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">fun</span> <span class="nf">a</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="n">interface</span> <span class="n">B</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// interface members are &#39;open&#39; by default</span>
  <span class="k">fun</span> <span class="nf">b</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">()</span> <span class="p">:</span> <span class="n">A</span><span class="p">(),</span> <span class="n">B</span> <span class="p">{</span>
  <span class="c1">// The compiler requires f() to be overridden:</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;.</span><span class="n">f</span><span class="p">()</span> <span class="c1">// call to A.f()</span>
    <span class="k">super</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;.</span><span class="n">f</span><span class="p">()</span> <span class="c1">// call to B.f()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>It’s fine to inherit from both <code>A</code> and <code>B</code>, and we have no problems with <code>a()</code> and <code>b()</code> since <code>C</code> inherits only one implementation of each of these functions.
But for <code>f()</code> we have two implementations inherited by <code>C</code>, and thus we have to override <code>f()</code> in <code>C</code>
and provide our own implementation that eliminates the ambiguity.</p>

<h2 id="abstract-classes">Abstract Classes<a href="#abstract-classes" class="anchor"></a></h2>

<p>A class and some of its members may be declared <em class="keyword">abstract</em>.
An abstract member does not have an implementation in its class.
Thus, when some descendant inherits an abstract member, it does not count as an implementation:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="k">abstract</span> <span class="k">fun</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span>

<span class="n">interface</span> <span class="n">B</span> <span class="p">{</span>
  <span class="k">open</span> <span class="k">fun</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span><span class="p">()</span> <span class="p">:</span> <span class="n">A</span><span class="p">(),</span> <span class="n">B</span> <span class="p">{</span>
  <span class="c1">// We are not required to override f()</span>
<span class="p">}</span></code></pre>

<p>Note that we do not need to annotate an abstract class or function with open – it goes without saying.</p>

<p>We can override a non-abstract open member with an abstract one</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">open</span> <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
  <span class="k">open</span> <span class="k">fun</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Derived</span> <span class="p">:</span> <span class="n">Base</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">abstract</span> <span class="k">fun</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">}</span></code></pre>

<h2 id="companion-objects">Companion Objects<a href="#companion-objects" class="anchor"></a></h2>

<p>In Kotlin, unlike Java or C#, classes do not have static methods. In most cases, it’s recommended to simply use
package-level functions instead.</p>

<p>If you need to write a function that can be called without having a class instance but needs access to the internals
of a class (for example, a factory method), you can write it as a member of an <a href="object-declarations.html">object declaration</a>
inside that class.</p>

<p>Even more specifically, if you declare a <a href="object-declarations.html#companion-objects">companion object</a> inside your class,
you’ll be able to call its members with the same syntax as calling static methods in Java/C#, using only the class name
as a qualifier.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/properties.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="properties-and-fields">Properties and Fields<a href="#properties-and-fields" class="anchor"></a></h1>

<h2 id="declaring-properties">Declaring Properties<a href="#declaring-properties" class="anchor"></a></h2>

<p>Classes in Kotlin can have properties.
These can be declared as mutable, using the <em class="keyword">var</em> keyword or read-only using the <em class="keyword">val</em> keyword.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">public</span> <span class="k">class</span> <span class="nc">Address</span> <span class="p">{</span> 
  <span class="k">public</span> <span class="k">var</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="p">...</span>
  <span class="k">public</span> <span class="k">var</span> <span class="py">street</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="p">...</span>
  <span class="k">public</span> <span class="k">var</span> <span class="py">city</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="p">...</span>
  <span class="k">public</span> <span class="k">var</span> <span class="py">state</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="p">...</span>
  <span class="k">public</span> <span class="k">var</span> <span class="py">zip</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="p">...</span>
<span class="p">}</span></code></pre>

<p>To use a property, we simply refer to it by name, as if it were a field in Java:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">copyAddress</span><span class="p">(</span><span class="n">address</span><span class="p">:</span> <span class="n">Address</span><span class="p">):</span> <span class="n">Address</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="n">Address</span><span class="p">()</span> <span class="c1">// there&#39;s no &#39;new&#39; keyword in Kotlin</span>
  <span class="n">result</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="n">address</span><span class="p">.</span><span class="n">name</span> <span class="c1">// accessors are called</span>
  <span class="n">result</span><span class="p">.</span><span class="n">street</span> <span class="p">=</span> <span class="n">address</span><span class="p">.</span><span class="n">street</span>
  <span class="c1">// ...</span>
  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span></code></pre>

<h2 id="getters-and-setters">Getters and Setters<a href="#getters-and-setters" class="anchor"></a></h2>

<p>The full syntax for declaring a property is</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="err">&lt;</span><span class="py">propertyName</span><span class="p">&gt;:</span> <span class="p">&lt;</span><span class="n">PropertyType</span><span class="p">&gt;</span> <span class="p">[=</span> <span class="p">&lt;</span><span class="n">property_initializer</span><span class="p">&gt;]</span>
  <span class="p">&lt;</span><span class="n">getter</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="n">setter</span><span class="p">&gt;</span></code></pre>

<p>The initializer, getter and setter are optional. Property type is optional if it can be inferred from the initializer or from the base class member being overridden.</p>

<p>Examples:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="py">allByDefault</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="c1">// error: explicit initializer required, default getter and setter implied</span>
<span class="k">var</span> <span class="py">initialized</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// has type Int, default getter and setter</span></code></pre>

<p>Note that types are not inferred for properties exposed as parts of the public API, i.e. public and protected,
because changing the initializer may cause an unintentional change in the public API then. For example:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">public</span> <span class="k">val</span> <span class="py">example</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// error: a public property must have a type specified explicitly</span></code></pre>

<p>The full syntax of a read-only property declaration differs from a mutable one in two ways: it starts with val instead of var and does not allow a setter:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">simple</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="c1">// has type Int, default getter, must be initialized in constructor</span>
<span class="k">val</span> <span class="py">inferredType</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// has type Int and a default getter</span></code></pre>

<p>We can write custom accessors, very much like ordinary functions, right inside a property declaration. Here’s an example of a custom getter:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">isEmpty</span><span class="p">:</span> <span class="n">Boolean</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">size</span> <span class="p">==</span> <span class="m">0</span></code></pre>

<p>A custom setter looks like this:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="py">stringRepresentation</span><span class="p">:</span> <span class="n">String</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
  <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">setDataFromString</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1">// parses the string and assigns values to other properties</span>
  <span class="p">}</span></code></pre>

<p>By convention, the name of the setter parameter is <code>value</code>, but you can choose a different name if you prefer.</p>

<p>If you need to change the visibility of an accessor or to annotate it, but don’t need to change the default implementation,
you can define the accessor without defining its body:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="py">setterVisibility</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span> <span class="c1">// Initializer required, not a nullable type</span>
  <span class="k">private</span> <span class="k">set</span> <span class="c1">// the setter is private and has the default implementation</span>

<span class="k">var</span> <span class="py">setterWithAnnotation</span><span class="p">:</span> <span class="n">Any</span><span class="p">?</span>
  <span class="n">@Inject</span> <span class="k">set</span> <span class="c1">// annotate the setter with Inject</span></code></pre>

<h3 id="backing-fields">Backing Fields<a href="#backing-fields" class="anchor"></a></h3>

<p>Classes in Kotlin cannot have fields. However, sometimes it is necessary to have a backing field when using custom accessors. For these purposes, Kotlin provides
an automatic backing field which can be accessed using the <em>$</em> symbol followed by the property name.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="py">counter</span> <span class="p">=</span> <span class="m">0</span> <span class="c1">// the initializer value is written directly to the backing field</span>
  <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">)</span>
      <span class="err">$</span><span class="n">counter</span> <span class="p">=</span> <span class="n">value</span>
  <span class="p">}</span></code></pre>

<p>The <code>$counter</code> field can be accessed only from inside the class where the counter property is defined.</p>

<p>The compiler looks at the accessors’ bodies, and if they use the backing field (or the accessor implementation is left by default), a backing field is generated, otherwise it is not.</p>

<p>For example, in the following case there will be no backing field:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">isEmpty</span><span class="p">:</span> <span class="n">Boolean</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">size</span> <span class="p">==</span> <span class="m">0</span></code></pre>

<h3 id="backing-properties">Backing Properties<a href="#backing-properties" class="anchor"></a></h3>

<p>If you want to do something that does not fit into this “implicit backing field” scheme, you can always fall back to having a <em>backing property</em>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">private</span> <span class="k">var</span> <span class="py">_table</span><span class="p">:</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;?</span> <span class="p">=</span> <span class="k">null</span>
<span class="k">public</span> <span class="k">val</span> <span class="py">table</span><span class="p">:</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_table</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
      <span class="n">_table</span> <span class="p">=</span> <span class="n">HashMap</span><span class="p">()</span> <span class="c1">// Type parameters are inferred</span>
    <span class="k">return</span> <span class="n">_table</span> <span class="o">?:</span> <span class="k">throw</span> <span class="n">AssertionError</span><span class="p">(</span><span class="s">&quot;Set to null by another thread&quot;</span><span class="p">)</span>
  <span class="p">}</span></code></pre>

<p>In all respects, this is just the same as in Java since access to private properties with default getters and setters is optimized so that no function call overhead is introduced.</p>

<h2 id="overriding-properties">Overriding Properties<a href="#overriding-properties" class="anchor"></a></h2>

<p>See <a href="classes.html#overriding-members">Overriding Members</a></p>

<h2 id="delegated-properties">Delegated Properties<a href="#delegated-properties" class="anchor"></a></h2>

<p>The most common kind of properties simply reads from (and maybe writes to) a backing field. 
On the other hand, with custom getters and setters one can implement any behaviour of a property.
Somewhere in between, there are certain common patterns of how a property may work. A few examples: lazy values,
reading from a map by a given key, accessing a database, notifying listener on access, etc.</p>

<p>Such common behaviours can be implemented as libraries using <em>delegated properties</em>.
For more information, look <a href="delegated-properties.html">here</a>.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/interfaces.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="interfaces">Interfaces<a href="#interfaces" class="anchor"></a></h1>

<p>Interfaces in Kotlin are very similar to Java 8. They can contain declarations of abstract methods, as well as method
implementations. What makes them different from abstract classes is that interfaces cannot store state. They can have
properties but these need to be abstract.</p>

<p>An interface is defined using the keyword <em class="keyword">interface</em></p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">interface</span> <span class="n">MyInterface</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span>
    <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// optional body</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>

<h2 id="implementing-interfaces">Implementing Interfaces<a href="#implementing-interfaces" class="anchor"></a></h2>

<p>A class or object can implement one or more interfaces</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="n">MyInterface</span> <span class="p">{</span>
   <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">// body</span>
   <span class="p">}</span>
<span class="p">}</span></code></pre>

<h2 id="properties-in-interfaces">Properties in Interfaces<a href="#properties-in-interfaces" class="anchor"></a></h2>

<p>Interfaces allow properties as long as these are stateless, that is because interfaces do not allow state.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">interface</span> <span class="n">MyInterface</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">property</span><span class="p">:</span> <span class="n">Int</span> <span class="c1">// abstract</span>

    <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">print</span><span class="p">(</span><span class="n">property</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Child</span> <span class="p">:</span> <span class="n">MyInterface</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">val</span> <span class="py">property</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">29</span>
<span class="p">}</span></code></pre>

<h2 id="resolving-overriding-conflicts">Resolving overriding conflicts<a href="#resolving-overriding-conflicts" class="anchor"></a></h2>

<p>When we declare many types in our supertype list, it may appear that we inherit more than one implementation of the same method. For example</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">interface</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span>
<span class="p">}</span>

<span class="n">interface</span> <span class="n">B</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">)</span> <span class="p">}</span>
  <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">:</span> <span class="n">A</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;bar&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">D</span> <span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">super</span><span class="p">&lt;</span><span class="n">A</span><span class="p">&gt;.</span><span class="n">foo</span><span class="p">()</span>
    <span class="k">super</span><span class="p">&lt;</span><span class="n">B</span><span class="p">&gt;.</span><span class="n">foo</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Interfaces <em>A</em> and <em>B</em> both declare functions <em>foo()</em> and <em>bar()</em>. Both of them implement <em>foo()</em>, but only <em>B</em> implements <em>bar()</em> (<em>bar()</em> is not marked abstract in <em>A</em>,
because this is the default for interfaces, if the function has no body). Now, if we derive a concrete class <em>C</em> from <em>A</em>, we, obviously, have to override <em>bar()</em> and provide
an implementation. And if we derive <em>D</em> from <em>A</em> and <em>B</em>, we don’t have to override <em>bar()</em>, because we have inherited only one implementation of it.
But we have inherited two implementations of <em>foo()</em>, so the compiler does not know which one to choose, and forces us to override <em>foo()</em> and say what we want explicitly.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/visibility-modifiers.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="visibility-modifiers">Visibility Modifiers<a href="#visibility-modifiers" class="anchor"></a></h1>

<p>Classes, objects, interfaces, constructors, functions, properties and their setters can have <em>visibility modifiers</em>.
(Getters always have the same visibility as the property.) 
There are four visibility modifiers in Kotlin:</p>

<ul>
  <li><code>private</code> — visible only in the declaring scope and its subscopes (inside the same module);</li>
  <li><code>protected</code> — (applicable only to class/interface members) like <code>private</code>, but also visible in subclasses;</li>
  <li><code>internal</code> — (used by default) visible everywhere within the same module (if the owner of declaring scope is visible);</li>
  <li><code>public</code> — visible everywhere (if the owner of declaring scope is visible).</li>
</ul>

<p><strong>NOTE</strong>: Functions <em>with expression bodies</em> and all properties declared <code>public</code> must always specify return types explicitly. 
This is required so that we do not accidentally change a type that is a part of a public API by merely
altering the implementation.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">public</span> <span class="k">val</span> <span class="py">foo</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">5</span>    <span class="c1">// explicit return type required</span>
<span class="k">public</span> <span class="k">fun</span> <span class="nf">bar</span><span class="p">():</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">5</span>  <span class="c1">// explicit return type required</span>
<span class="k">public</span> <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{}</span>        <span class="c1">// block body: return type is Unit and can&#39;t be changed accidentally, so not required</span></code></pre>

<p>Below please find explanations of these for different type of declaring scopes.  </p>

<h2 id="packages">Packages<a href="#packages" class="anchor"></a></h2>

<p>Functions, properties and classes, objects and interfaces can be declared on the “top-level”, i.e. directly inside a package:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// file name: example.kt</span>
<span class="k">package</span> <span class="nn">foo</span>

<span class="k">fun</span> <span class="nf">baz</span><span class="p">()</span> <span class="p">{}</span>
<span class="k">class</span> <span class="nc">Bar</span> <span class="p">{}</span></code></pre>

<ul>
  <li>If you do not specify any visibility modifier, <code>internal</code> is used by default, which means that your declarations will be 
visible everywhere within the same module;  </li>
  <li>If you mark a declaration <code>private</code>, it will only be visible inside this package and its subpackages, and only within 
the same module;</li>
  <li>If you mark it <code>public</code>, it is visible everywhere;</li>
  <li><code>protected</code> is not available for top-level declarations.</li>
</ul>

<p>Examples:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// file name: example.kt</span>
<span class="k">package</span> <span class="nn">foo</span>

<span class="k">private</span> <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// visible inside this package and subpackaged</span>

<span class="k">public</span> <span class="k">var</span> <span class="py">bar</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">5</span> <span class="c1">// property is visible everywhere</span>
    <span class="k">private</span> <span class="k">set</span>         <span class="c1">// setter is visible only in this package and subpackages</span>
    
<span class="k">internal</span> <span class="k">val</span> <span class="py">baz</span> <span class="p">=</span> <span class="m">6</span>    <span class="c1">// visible inside the same module, the modifier can be omitted    </span></code></pre>

<h2 id="classes-and-interfaces">Classes and Interfaces<a href="#classes-and-interfaces" class="anchor"></a></h2>

<p>When declared inside a class:</p>

<ul>
  <li><code>private</code> means visible inside this class only (including all its members);</li>
  <li><code>protected</code> — same as <code>private</code> + visible in subclasses too;</li>
  <li><code>internal</code> — any client <em>inside this module</em> who sees the declaring class sees its <code>internal</code> members;</li>
  <li><code>public</code> — any client who sees the declaring class sees its <code>public</code> members.</li>
</ul>

<p><em>NOTE</em> for Java users: outer class does not see private members of its inner classes in Kotlin.</p>

<p>Examples:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">open</span> <span class="k">class</span> <span class="nc">Outer</span> <span class="p">{</span>
    <span class="k">private</span> <span class="k">val</span> <span class="py">a</span> <span class="p">=</span> <span class="m">1</span>
    <span class="k">protected</span> <span class="k">val</span> <span class="py">b</span> <span class="p">=</span> <span class="m">2</span>
    <span class="k">val</span> <span class="py">c</span> <span class="p">=</span> <span class="m">3</span> <span class="c1">// internal by default</span>
    <span class="k">public</span> <span class="k">val</span> <span class="py">d</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">4</span> <span class="c1">// return type required</span>
    
    <span class="k">protected</span> <span class="k">class</span> <span class="nc">Nested</span> <span class="p">{</span>
        <span class="k">public</span> <span class="k">val</span> <span class="py">e</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">5</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Subclass</span> <span class="p">:</span> <span class="n">Outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// a is not visible</span>
    <span class="c1">// b, c and d are visible</span>
    <span class="c1">// Nested and e are visible</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Unrelated</span><span class="p">(</span><span class="n">o</span><span class="p">:</span> <span class="n">Outer</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// o.a, o.b are not visible</span>
    <span class="c1">// o.c and o.d are visible (same module)</span>
    <span class="c1">// Outer.Nested is not visible, and Nested::e is not visible either </span>
<span class="p">}</span></code></pre>

<h3 id="constructors">Constructors<a href="#constructors" class="anchor"></a></h3>

<p>To specify a visibility of the primary constructor of a class, use the following syntax (note that you need to add an
explicit <em class="keyword">constructor</em> keyword):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">C</span> <span class="k">private</span> <span class="n">constructor</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre>

<p>Here the constructor is private. Unlike other declarations, by default, all constructors are <code>public</code>, which effectively
amounts to them being visible everywhere where the class is visible (i.e. a constructor of an <code>internal</code> class is only 
visible within the same module).</p>

<h3 id="local-declarations">Local declarations<a href="#local-declarations" class="anchor"></a></h3>

<p>Local variables, functions and classes can not have visibility modifiers.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/extensions.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="extensions">Extensions<a href="#extensions" class="anchor"></a></h1>

<p>Kotlin, similar to C# and Gosu, provides the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern such as Decorator.
This is done via special declarations called <em>extensions</em>. Currently, Kotlin supports <em>extension functions</em> and <em>extension properties</em>.</p>

<h2 id="extension-functions">Extension Functions<a href="#extension-functions" class="anchor"></a></h2>

<p>To declare an extension function, we need to prefix its name with a <em>receiver type</em>, i.e. the type being extended.
The following adds a <code>swap</code> function to <code>MutableList&lt;Int&gt;</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">MutableList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;.</span><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">tmp</span> <span class="p">=</span> <span class="k">this</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="c1">// &#39;this&#39; corresponds to the list</span>
  <span class="k">this</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">=</span> <span class="k">this</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
  <span class="k">this</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="p">=</span> <span class="n">tmp</span>
<span class="p">}</span></code></pre>

<p>The <em class="keyword">this</em> keyword inside an extension function corresponds to the receiver object (the one that is passed before the dot). 
Now, we can call such a function on any <code>MutableList&lt;Int&gt;</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
<span class="n">l</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span> <span class="c1">// &#39;this&#39; inside &#39;swap()&#39; will hold the value of &#39;l&#39;</span></code></pre>

<p>Of course, this function makes sense for any <code>MutableList&lt;T&gt;</code>, and we can make it generic:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">MutableList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">swap</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">tmp</span> <span class="p">=</span> <span class="k">this</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="c1">// &#39;this&#39; corresponds to the list</span>
  <span class="k">this</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="p">=</span> <span class="k">this</span><span class="p">[</span><span class="n">y</span><span class="p">]</span>
  <span class="k">this</span><span class="p">[</span><span class="n">y</span><span class="p">]</span> <span class="p">=</span> <span class="n">tmp</span>
<span class="p">}</span></code></pre>

<p>We declare the generic type parameter before the function name for it to be available in the receiver type expression. 
See <a href="generics.html">Generic functions</a>.</p>

<h2 id="extensions-are-resolved-statically">Extensions are resolved <strong>statically</strong><a href="#extensions-are-resolved-statically" class="anchor"></a></h2>

<p>Extensions do not actually modify classes they extend. By defining an extension, you do not insert new members into a class,
but merely make new functions callable with the dot-notation on instances of this class.</p>

<p>We would like to emphasize that extension functions are dispatched <strong>statically</strong>, i.e. they are not virtual by receiver type.
If there’s a member and extension of the same type both applicable to given arguments, a <strong>member always wins</strong>. 
For example:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;member&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">C</span><span class="p">.</span><span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;extension&quot;</span><span class="p">)</span> <span class="p">}</span></code></pre>

<p>If we call <code>c.foo()</code> of any <code>c</code> of type <code>C</code>, it will print “member”, not “extension”.</p>

<h2 id="nullable-receiver">Nullable Receiver<a href="#nullable-receiver" class="anchor"></a></h2>

<p>Note that extensions can be defined with a nullable receiver type. Such extensions can be called on an object variable
even if its value is null, and can check for <code>this == null</code> inside the body. This is what allows you
to call toString() in Kotlin without checking for null: the check happens inside the extension function.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">Any</span><span class="o">?.</span><span class="n">toString</span><span class="p">():</span> <span class="n">String</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="s">&quot;null&quot;</span>
    <span class="c1">// after the null check, &#39;this&#39; is autocast to a non-null type, so the toString() below</span>
    <span class="c1">// resolves to the member function of the Any class</span>
    <span class="k">return</span> <span class="n">toString</span><span class="p">()</span>
<span class="p">}</span></code></pre>

<h2 id="extension-properties">Extension Properties<a href="#extension-properties" class="anchor"></a></h2>

<p>Similarly to functions, Kotlin supports extension properties:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="err">&lt;</span><span class="py">T</span><span class="p">&gt;</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">lastIndex</span><span class="p">:</span> <span class="n">Int</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">size</span> <span class="p">-</span> <span class="m">1</span></code></pre>

<p>Note that, since extensions do not actually insert members into classes, there’s no efficient way for an extension 
property to have a <a href="properties.html#backing-fields">backing field</a>. This is why <strong>initializers are not allowed for 
extension properties</strong>. Their behavior can only be defined by explicitly providing getters/setters.</p>

<p>Example:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">Foo</span><span class="p">.</span><span class="n">bar</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// error: initializers are not allowed for extension properties</span></code></pre>

<h2 id="companion-object-extensions">Companion Object Extensions<a href="#companion-object-extensions" class="anchor"></a></h2>

<p>If a class has a <a href="object-declarations.html#companion-objects">companion object</a> defined, you can also define extension
functions and properties for the companion object:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="n">companion</span> <span class="k">object</span> <span class="err">{ }  // </span><span class="nc">will</span> <span class="n">be</span> <span class="n">called</span> <span class="s">&quot;Companion&quot;</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">MyClass</span><span class="p">.</span><span class="n">Companion</span><span class="p">.</span><span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>Just like regular members of the companion object, they can be called using only the class name as the qualifier:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">MyClass</span><span class="p">.</span><span class="n">foo</span><span class="p">()</span></code></pre>

<h2 id="scope-of-extensions">Scope of Extensions<a href="#scope-of-extensions" class="anchor"></a></h2>

<p>Most of the time we define extensions on the top level, i.e. directly under packages:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">package</span> <span class="nn">foo.bar</span>
 
<span class="k">fun</span> <span class="nf">Baz</span><span class="p">.</span><span class="n">goo</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre>

<p>To use such an extension outside its declaring package, we need to import it at the call site:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">package</span> <span class="nn">com.example.usage</span>

<span class="k">import</span> <span class="nn">foo.bar.goo</span> <span class="c1">// importing all extensions by name &quot;goo&quot;</span>
                   <span class="c1">// or</span>
<span class="k">import</span> <span class="nn">foo.bar.*</span>   <span class="c1">// importing everything from &quot;foo.bar&quot;</span>

<span class="k">fun</span> <span class="nf">usage</span><span class="p">(</span><span class="n">baz</span><span class="p">:</span> <span class="n">Baz</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">baz</span><span class="p">.</span><span class="n">goo</span><span class="p">()</span>
<span class="p">)</span></code></pre>

<p>See <a href="packages.html#imports">Imports</a> for more information.</p>

<h2 id="motivation">Motivation<a href="#motivation" class="anchor"></a></h2>

<p>In Java, we are used to classes named “*Utils”: <code>FileUtils</code>, <code>StringUtils</code> and so on. The famous <code>java.util.Collections</code> belongs to the same breed.
And the unpleasant part about these Utils-classes is that the code that uses them looks like this:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="n">Collections</span><span class="o">.</span><span class="na">swap</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">Collections</span><span class="o">.</span><span class="na">binarySearch</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">otherList</span><span class="o">)),</span> <span class="n">Collections</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">list</span><span class="o">))</span></code></pre>

<p>Those class names are always getting in the way. We can use static imports and get this:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="n">swap</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">binarySearch</span><span class="o">(</span><span class="n">list</span><span class="o">,</span> <span class="n">max</span><span class="o">(</span><span class="n">otherList</span><span class="o">)),</span> <span class="n">max</span><span class="o">(</span><span class="n">list</span><span class="o">))</span></code></pre>

<p>This is a little better, but we have no or little help from the powerful code completion of the IDE. It would be so much better if we could say</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="n">list</span><span class="o">.</span><span class="na">swap</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">binarySearch</span><span class="o">(</span><span class="n">otherList</span><span class="o">.</span><span class="na">max</span><span class="o">()),</span> <span class="n">list</span><span class="o">.</span><span class="na">max</span><span class="o">())</span></code></pre>

<p>But we don’t want to implement all the possible methods inside the class <code>List</code>, right? This is where extensions help us.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/data-classes.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="data-classes">Data Classes<a href="#data-classes" class="anchor"></a></h1>

<p>We frequently create classes that do nothing but hold data. In such classes some functionality is often mechanically
derivable from the data they hold. In Kotlin a class can be annotated as <code>data</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">data</span> <span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="k">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span></code></pre>

<p>This is called a <em>data class</em>. The compiler automatically derives the following members from all properties <em>declared in 
the primary constructor</em>:</p>

<ul>
  <li><code>equals()</code>/<code>hashCode()</code> pair, </li>
  <li><code>toString()</code> of the form <code>"User(name=John, age=42)"</code>,</li>
  <li><a href="multi-declarations.html"><code>componentN()</code> functions</a> corresponding to the properties in their order or declaration,</li>
  <li><code>copy()</code> function (see below).</li>
</ul>

<p>If any of these functions is explicitly defined in the class body or inherited from the base types, it will not be generated.  </p>

<p><em>NOTE</em> that if a constructor parameter does not have a <code>val</code> or <code>var</code> in front of it, it will not be included in computation
of all these functions; nor will be properties declared in the class body or inherited from the superclass.</p>

<blockquote>
  <p>On the JVM, if the generated class needs to have a parameterless constructor, default values for all properties have to be specified
(see <a href="classes.html#constructors">Constructors</a>).</p>

  <pre><code class="code-block _highlighted lang_kotlin"><span class="n">data</span> <span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="k">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span><span class="p">)</span></code></pre>
</blockquote>

<h2 id="copying">Copying<a href="#copying" class="anchor"></a></h2>

<p>It’s often the case that we need to copy an object altering <em>some</em> of its properties, but keeping the rest unchanged. 
This is what <code>copy()</code> function is generated for. For the <code>User</code> class above, its implementation would be as follows:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">copy</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">age</span><span class="p">)</span> <span class="p">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span></code></pre>

<p>This allows us to write</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">jack</span> <span class="p">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span> <span class="p">=</span> <span class="s">&quot;Jack&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="p">=</span> <span class="m">1</span><span class="p">)</span>
<span class="k">val</span> <span class="py">olderJack</span> <span class="p">=</span> <span class="n">jack</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">age</span> <span class="p">=</span> <span class="m">2</span><span class="p">)</span></code></pre>

<h2 id="data-classes-and-multi-declarations">Data Classes and Multi-Declarations<a href="#data-classes-and-multi-declarations" class="anchor"></a></h2>

<p><em>Component functions</em> generated for data classes enable their use in <a href="multi-declarations.html">multi-declarations</a>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">jane</span> <span class="p">=</span> <span class="n">User</span><span class="p">(</span><span class="s">&quot;Jane&quot;</span><span class="p">,</span> <span class="m">35</span><span class="p">)</span> 
<span class="k">val</span> <span class="err">(</span><span class="py">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="p">=</span> <span class="n">jane</span>
<span class="n">println</span><span class="p">(</span><span class="s">&quot;$name, $age years of age&quot;</span><span class="p">)</span> <span class="c1">// prints &quot;Jane, 35 years of age&quot;</span></code></pre>

<h2 id="standard-data-classes">Standard Data Classes<a href="#standard-data-classes" class="anchor"></a></h2>

<p>The standard library provides <code>Pair</code> and <code>Triple</code>. In most cases, though, named data classes are a better design choice, 
because they make the code more readable by providing meaningful names for properties.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/generics.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="generics">Generics<a href="#generics" class="anchor"></a></h1>

<p>As in Java, classes in Kotlin may have type parameters:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="py">value</span> <span class="p">=</span> <span class="n">t</span>
<span class="p">}</span></code></pre>

<p>In general, to create an instance of such a class, we need to provide the type arguments:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">box</span><span class="p">:</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">)</span></code></pre>

<p>But if the parameters may be inferred, e.g. from the constructor arguments or by some other means, one is allowed to omit the type arguments:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">box</span> <span class="p">=</span> <span class="n">Box</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="c1">// 1 has type Int, so the compiler figures out that we are talking about Box&lt;Int&gt;</span></code></pre>

<h2 id="variance">Variance<a href="#variance" class="anchor"></a></h2>

<p>One of the most tricky parts of Java’s type system is wildcard types (see <a href="http://www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html">Java Generics FAQ</a>).
And Kotlin doesn’t have any. Instead, it has two other things: declaration-site variance and type projections.</p>

<p>First, let’s think about why Java needs those mysterious wildcards. The problem is explained in <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a>, Item 28: <em>Use bounded wildcards to increase API flexibility</em>.
First, generic types in Java are <strong>invariant</strong>, meaning that <code>List&lt;String&gt;</code> is <strong>not</strong> a subtype of <code>List&lt;Object&gt;</code>. 
Why so? If List was not <strong>invariant</strong>, it would have been no 
better than Java’s arrays, cause the following code would have compiled and cause an exception at runtime:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">strs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
<span class="n">List</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">objs</span> <span class="o">=</span> <span class="n">strs</span><span class="o">;</span> <span class="c1">// !!! The cause of the upcoming problem sits here. Java prohibits this!</span>
<span class="n">objs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span> <span class="c1">// Here we put an Integer into a list of Strings</span>
<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">strs</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span> <span class="c1">// !!! ClassCastException: Cannot cast Integer to String</span></code></pre>
<p>So, Java prohibits such things in order to guarantee run-time safety. But this has some implications. For example, consider the <code>addAll()</code> method from <code>Collection</code> 
interface. What’s the signature of this method? Intuitively, we’d put it this way:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="kd">interface</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">...</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">);</span>
<span class="o">}</span></code></pre>

<p>But then, we would not be able to do the following simple thing (which is perfectly safe):</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="kt">void</span> <span class="nf">copyAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">to</span><span class="o">,</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">from</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">to</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">from</span><span class="o">);</span> <span class="c1">// !!! Would not compile with the naive declaration of addAll:</span>
                   <span class="c1">//       Collection&lt;String&gt; is not a subtype of Collection&lt;Object&gt;</span>
<span class="o">}</span></code></pre>

<p>(In Java, we learned this lesson the hard way, see <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a>, Item 25: <em>Prefer lists to arrays</em>)</p>

<p>That’s why the actual signature of <code>addAll()</code> is the following:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="kd">interface</span> <span class="nc">Collection</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">...</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">Collection</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">);</span>
<span class="o">}</span></code></pre>

<p>The <strong>wildcard type argument</strong> <code>? extends T</code> indicates that this method accepts a collection of objects of <em>some subtype of</em> <code>T</code>, not <code>T</code> itself. 
This means that we can safely <strong>read</strong> <code>T</code>’s from items (elements of this collection are instances of a subclass of T), but <strong>cannot write</strong> to 
it since we do not know what objects comply to that unknown subtype of <code>T</code>. 
In return for this limitation, we have the desired behaviour: <code>Collection&lt;String&gt;</code> <em>is</em> a subtype of <code>Collection&lt;? extends Object&gt;</code>. 
In “clever words”, the wildcard with an <strong>extends</strong>-bound (<strong>upper</strong> bound) makes the type <strong>covariant</strong>.</p>

<p>The key to understanding why this trick works is rather simple: if you can only <strong>take</strong> items from a collection, then using a collection of <code>String</code>s
and reading <code>Object</code>s from it is fine. Conversely, if you can only <em>put</em> items into the collection, it’s OK to take a collection of
<code>Object</code>s and put <code>String</code>s into it: in Java we have <code>List&lt;? super String&gt;</code> a <strong>supertype</strong> of <code>List&lt;Object&gt;</code>.</p>

<p>The latter is called <strong>contravariance</strong>, and you can only call methods that take String as an argument on <code>List&lt;? super String&gt;</code> 
(e.g., you can call <code>add(String)</code> or <code>set(int, String)</code>), while 
if you call something that returns <code>T</code> in <code>List&lt;T&gt;</code>, you don’t get a <code>String</code>, but an <code>Object</code>.</p>

<p>Joshua Bloch calls those objects you only <strong>read</strong> from <strong>Producers</strong>, and those you only <strong>write</strong> to <strong>Consumers</strong>. He recommends: “<em>For maximum flexibility, use wildcard types on input parameters that represent producers or consumers</em>”, and proposes the following mnemonic:</p>

<p><em>PECS stands for Producer-Extends, Consumer-Super.</em></p>

<p><em>NOTE</em>: if you use a producer-object, say, <code>List&lt;? extends Foo&gt;</code>, you are not allowed to call <code>add()</code> or <code>set()</code> on this object, but this does not mean 
that this object is <strong>immutable</strong>: for example, nothing prevents you from calling <code>clear()</code> to remove all items from the list, since <code>clear()</code> 
does not take any parameters at all. The only thing guaranteed by wildcards (or other types of variance) is <strong>type safety</strong>. Immutability is a completely different story.</p>

<h3 id="declaration-site-variance">Declaration-site variance<a href="#declaration-site-variance" class="anchor"></a></h3>

<p>Suppose we have a generic interface <code>Source&lt;T&gt;</code> that does not have any methods that take <code>T</code> as a parameter, only methods that return <code>T</code>:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="kd">interface</span> <span class="nc">Source</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="n">T</span> <span class="nf">nextT</span><span class="o">();</span>
<span class="o">}</span></code></pre>

<p>Then, it would be perfectly safe to store a reference to an instance of <code>Source&lt;String&gt;</code> in a variable of type <code>Source&lt;Object&gt;</code> – there are no consumer-methods to call. But Java does not know this, and still prohibits it:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="kt">void</span> <span class="nf">demo</span><span class="o">(</span><span class="n">Source</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">strs</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">Source</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">objects</span> <span class="o">=</span> <span class="n">strs</span><span class="o">;</span> <span class="c1">// !!! Not allowed in Java</span>
  <span class="c1">// ...</span>
<span class="o">}</span></code></pre>

<p>To fix this, we have to declare objects of type <code>Source&lt;? extends Object&gt;</code>, which is sort of meaningless, because we can call all the same methods on such a variable as before, so there’s no value added by the more complex type. But the compiler does not know that.</p>

<p>In Kotlin, there is a way to explain this sort of thing to the compiler. This is called <strong>declaration-site variance</strong>: we can annotate the <strong>type parameter</strong> <code>T</code> of Source to make sure that it is only <strong>returned</strong> (produced) from members of <code>Source&lt;T&gt;</code>, and never consumed. 
To do this we provide the <strong>out</strong> modifier:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Source</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">nextT</span><span class="p">():</span> <span class="n">T</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">demo</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">Source</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">objects</span><span class="p">:</span> <span class="n">Source</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">strs</span> <span class="c1">// This is OK, since T is an out-parameter</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>The general rule is: when a type parameter <code>T</code> of a class <code>C</code> is declared <strong>out</strong>, it may occur only in <strong>out</strong>-position in the members of <code>C</code>, but in return <code>C&lt;Base&gt;</code> can safely be a supertype 
of <code>C&lt;Derived&gt;</code>.</p>

<p>In “clever words” they say that the class <code>C</code> is <strong>covariant</strong> in the parameter <code>T</code>, or that <code>T</code> is a <strong>covariant</strong> type parameter. 
You can think of <code>C</code> as being a <strong>producer</strong> of <code>T</code>’s, and NOT a <strong>consumer</strong> of <code>T</code>’s.</p>

<p>The <strong>out</strong> modifier is called a <strong>variance annotation</strong>, and  since it is provided at the type parameter declaration site, we talk about <strong>declaration-site variance</strong>. 
This is in contrast with Java’s <strong>use-site variance</strong> where wildcards in the type usages make the types covariant.</p>

<p>In addition to <strong>out</strong>, Kotlin provides a complementary variance annotation: <strong>in</strong>. It makes a type parameter <strong>contravariant</strong>: it can only be consumed and never 
produced. A good example of a contravariant class is <code>Comparable</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Comparable</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">compareTo</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Int</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">demo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">Number</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="n">x</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="m">1.0</span><span class="p">)</span> <span class="c1">// 1.0 has type Double, which is a subtype of Number</span>
  <span class="c1">// Thus, we can assign x to a variable of type Comparable&lt;Double&gt;</span>
  <span class="k">val</span> <span class="py">y</span><span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">Double</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">x</span> <span class="c1">// OK!</span>
<span class="p">}</span></code></pre>

<p>We believe that the words <strong>in</strong> and <strong>out</strong> are self-explaining (as they were successfully used in C# for quite some time already), 
thus the mnemonic mentioned above is not really needed, and one can rephrase it for a higher purpose:</p>

<p><strong><a href="http://en.wikipedia.org/wiki/Existentialism">The Existential</a> Transformation: Consumer in, Producer out!</strong> :-)</p>

<h2 id="type-projections">Type projections<a href="#type-projections" class="anchor"></a></h2>

<h3 id="use-site-variance-type-projections">Use-site variance: Type projections<a href="#use-site-variance-type-projections" class="anchor"></a></h3>

<p>It is very convenient to declare a type parameter T as <em>out</em> and have no trouble with subtyping on the use site. Yes, it is, when the class in question <strong>can</strong> actually be restricted to only return <code>T</code>’s, but what if it can’t? 
A good example of this is Array:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Array</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">val</span> <span class="py">length</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">get</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">T</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
  <span class="k">fun</span> <span class="nf">set</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>This class cannot be either co- or contravariant in <code>T</code>. And this imposes certain inflexibilities. Consider the following function:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">copy</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;,</span> <span class="n">to</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">from</span><span class="p">.</span><span class="n">length</span> <span class="p">==</span> <span class="n">to</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">from</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span>
    <span class="n">to</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">from</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span></code></pre>

<p>This function is supposed to copy items from one array to another. Let’s try to apply it in practice:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">ints</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">array</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
<span class="k">val</span> <span class="py">any</span> <span class="p">=</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;(</span><span class="m">3</span><span class="p">)</span>
<span class="n">copy</span><span class="p">(</span><span class="n">ints</span><span class="p">,</span> <span class="n">any</span><span class="p">)</span> <span class="c1">// Error: expects (Array&lt;Any&gt;, Array&lt;Any&gt;)</span></code></pre>

<p>Here we run into the same familiar problem: <code>Array&lt;T&gt;</code> is <strong>invariant</strong> in <code>T</code>, thus neither of <code>Array&lt;Int&gt;</code> and <code>Array&lt;Any&gt;</code> 
is a subtype of the other. Why? Again, because copy <strong>might</strong> be doing bad things, i.e. it might attempt to <strong>write</strong>, say, a String to <code>from</code>,
and if we actually passed an array of <code>Int</code> there, a <code>ClassCastException</code> would have been thrown sometime later.</p>

<p>Then, the only thing we want to ensure is that <code>copy()</code> does not do any bad things. We want to prohibit it from <strong>writing</strong> to <code>from</code>, and we can:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">copy</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">Any</span><span class="p">&gt;,</span> <span class="n">to</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;)</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>What has happened here is called <strong>type projection</strong>: we said that <code>from</code> is not simply an array, but a restricted (<strong>projected</strong>) one: we can only call those methods that return the type parameter 
<code>T</code>, in this case it means that we can only call <code>get()</code>. This is our approach to <strong>use-site variance</strong>, and corresponds to Java’s <code>Array&lt;? extends Object&gt;</code>, 
but in a slightly simpler way.</p>

<p>You can project a type with <strong>in</strong> as well:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">fill</span><span class="p">(</span><span class="n">dest</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">String</span><span class="p">&gt;,</span> <span class="n">value</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p><code>Array&lt;in String&gt;</code> corresponds to Java’s <code>Array&lt;? super String&gt;</code>, i.e. you can pass an array of <code>CharSequence</code> or an array of <code>Object</code> to the <code>fill()</code> function.</p>

<h3 id="star-projections">Star-projections<a href="#star-projections" class="anchor"></a></h3>

<p>Sometimes you want to say that you know nothing about the type argument, but still want to use it in a safe way. 
The safe way here is to say that we are dealing with an <em>out</em>-projection 
(the object does not consume any values of unknown types), and that this projection is with the upper bound of the corresponding parameter, i.e. <code>out Any?</code> 
for most cases. Kotlin provides a shorthand syntax for this, that we call a <strong>star-projection</strong>: <code>Foo&lt;*&gt;</code> means <code>Foo&lt;out Bar&gt;</code> where <code>Bar</code>
 is the upper bound for <code>Foo</code>’s type parameter.</p>

<p><em>Note</em>: star-projections are very much like Java’s raw types, but safe.</p>

<h1 id="generic-functions">Generic functions<a href="#generic-functions" class="anchor"></a></h1>

<p>Not only classes can have type parameters. Functions can, too. Usually, we place the type parameters in angle brackets <strong>after</strong> the name of the function:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">singletonList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>But for <a href="extensions.html">Extension functions</a> it may be necessary to declare type parameters before specifying the receiver type, so 
Kotlin allows the alternative syntax:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">T</span><span class="p">.</span><span class="n">basicToString</span><span class="p">()</span> <span class="p">:</span> <span class="n">String</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">typeinfo</span><span class="p">.</span><span class="n">typeinfo</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="p">+</span> <span class="s">&quot;@&quot;</span> <span class="p">+</span> <span class="n">System</span><span class="p">.</span><span class="n">identityHashCode</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>If type parameters are passed explicitly at the call site, they can be only specified <strong>after</strong> the name of the function:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">singletonList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">)</span></code></pre>

<h1 id="generic-constraints">Generic constraints<a href="#generic-constraints" class="anchor"></a></h1>

<p>The set of all possible types that can be substituted for a given type parameter may be restricted by <strong>generic constraints</strong>.</p>

<h2 id="upper-bounds">Upper bounds<a href="#upper-bounds" class="anchor"></a></h2>

<p>The most common type of constraint is an <strong>upper bound</strong> that corresponds to Java’s <em>extends</em> keyword:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">sort</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;(</span><span class="n">list</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>The type specified after a colon is the <strong>upper bound</strong>: only a subtype of <code>Comparable&lt;T&gt;</code> may be substituted for <code>T</code>. For example</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">sort</span><span class="p">(</span><span class="n">list</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">))</span> <span class="c1">// OK. Int is a subtype of Comparable&lt;Int&gt;</span>
<span class="n">sort</span><span class="p">(</span><span class="n">list</span><span class="p">(</span><span class="n">HashMap</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;()))</span> <span class="c1">// Error: HashMap&lt;Int, String&gt; is not a subtype of Comparable&lt;HashMap&lt;Int, String&gt;&gt;</span></code></pre>

<p>The default upper bound (if none specified) is <code>Any?</code>. Only one upper bound can be specified inside the angle brackets.
If the same type parameter needs more than one upper bound, we need a separate <strong>where</strong>-clause:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">cloneWhenGreater</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;(</span><span class="n">list</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
    <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">Cloneable</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">list</span> <span class="k">when</span> <span class="p">{</span><span class="n">it</span> <span class="p">&gt;</span> <span class="n">threshold</span><span class="p">}</span> <span class="n">map</span> <span class="p">{</span><span class="n">it</span><span class="p">.</span><span class="n">clone</span><span class="p">()}</span>
<span class="p">}</span></code></pre>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/nested-classes.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="nested-classes">Nested Classes<a href="#nested-classes" class="anchor"></a></h1>

<p>Classes can be nested in other classes</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Outer</span> <span class="p">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="py">bar</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">1</span>
  <span class="k">class</span> <span class="nc">Nested</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">=</span> <span class="m">2</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">val</span> <span class="py">demo</span> <span class="p">=</span> <span class="n">Outer</span><span class="p">.</span><span class="n">Nested</span><span class="p">().</span><span class="n">foo</span><span class="p">()</span> <span class="c1">// == 2</span></code></pre>

<h2 id="inner-classes">Inner classes<a href="#inner-classes" class="anchor"></a></h2>

<p>A class may be marked as <em class="keyword">inner</em> to be able to access members of outer class. Inner classes carry a reference to an object of an outer class:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Outer</span> <span class="p">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="py">bar</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">1</span>
  <span class="k">inner</span> <span class="k">class</span> <span class="nc">Inner</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">=</span> <span class="n">bar</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">val</span> <span class="py">demo</span> <span class="p">=</span> <span class="n">Outer</span><span class="p">().</span><span class="n">Inner</span><span class="p">().</span><span class="n">foo</span><span class="p">()</span> <span class="c1">// == 1</span></code></pre>

<p>See <a href="this-expressions.html">Qualified <em class="keyword">this</em> expressions</a> to learn about disambiguation of <em class="keyword">this</em> in inner classes.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/enum-classes.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="enum-classes">Enum Classes<a href="#enum-classes" class="anchor"></a></h1>

<p>The most basic usage of enum classes is implementing type-safe enums</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Direction</span> <span class="p">{</span>
  <span class="n">NORTH</span><span class="p">,</span> <span class="n">SOUTH</span><span class="p">,</span> <span class="n">WEST</span><span class="p">,</span> <span class="n">EAST</span>
<span class="p">}</span></code></pre>

<p>Each enum constant is an object. Enum constants are separated with commas.</p>

<h2 id="initialization">Initialization<a href="#initialization" class="anchor"></a></h2>

<p>Since each enum is an instance of the enum class, they can be initialized</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span><span class="p">(</span><span class="k">val</span> <span class="py">rgb</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RED</span><span class="p">(</span><span class="m">0</span><span class="n">xFF0000</span><span class="p">),</span>
    <span class="n">GREEN</span><span class="p">(</span><span class="m">0</span><span class="n">x00FF00</span><span class="p">),</span>
    <span class="n">BLUE</span><span class="p">(</span><span class="m">0</span><span class="n">x0000FF</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<h2 id="anonymous-classes">Anonymous Classes<a href="#anonymous-classes" class="anchor"></a></h2>

<p>Enum constants can also declare their own anonymous classes</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">enum</span> <span class="k">class</span> <span class="nc">ProtocolState</span> <span class="p">{</span>
  <span class="n">WAITING</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">signal</span><span class="p">()</span> <span class="p">=</span> <span class="n">TALKING</span>
  <span class="p">},</span>

  <span class="n">TALKING</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">signal</span><span class="p">()</span> <span class="p">=</span> <span class="n">WAITING</span>
  <span class="p">};</span>

  <span class="k">abstract</span> <span class="k">fun</span> <span class="nf">signal</span><span class="p">():</span> <span class="n">ProtocolState</span>
<span class="p">}</span></code></pre>

<p>with their corresponding methods, as well as overriding base methods. Note that if the enum class defines any
members, you need to separate the enum constant definitions from the member definitions with a semicolon, just like
in Java.</p>

<h2 id="working-with-enum-constants">Working with Enum Constants<a href="#working-with-enum-constants" class="anchor"></a></h2>

<p>Just like in Java, enum classes in Kotlin have synthetic methods allowing to list
the defined enum constants and to get an enum constant by its name. The signatures
of these methods are as follows (assuming the name of the enum class is <code>EnumClass</code>):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">EnumClass</span><span class="p">.</span><span class="n">valueOf</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">EnumClass</span>
<span class="n">EnumClass</span><span class="p">.</span><span class="n">values</span><span class="p">():</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">EnumClass</span><span class="p">&gt;</span></code></pre>

<p>The <code>valueOf()</code> method throws an <code>IllegalArgumentException</code> if the specified name does
not match any of the enum constants defined in the class.</p>

<p>Every enum constant has methods to obtain its name and position in the enum class declaration:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">name</span><span class="p">():</span> <span class="n">String</span>
<span class="n">ordinal</span><span class="p">():</span> <span class="n">Int</span></code></pre>

<p>The enum constants also implement the <a href="/api/latest/jvm/stdlib/kotlin/-comparable/index.html">Comparable</a> interface,
with the natural order being the order in which they are defined in the enum class.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/object-declarations.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="object-expressions-and-declarations">Object Expressions and Declarations<a href="#object-expressions-and-declarations" class="anchor"></a></h1>

<p>Sometimes we need to create an object of a slight modification of some class, without explicitly declaring a new subclass for it.
Java handles this case with <em>anonymous inner classes</em>.
Kotlin slightly generalizes this concept with <em>object expressions</em> and <em>object declarations</em>.</p>

<h2 id="object-expressions">Object expressions<a href="#object-expressions" class="anchor"></a></h2>

<p>To create an object of an anonymous class that inherits from some type (or types), we write:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">window</span><span class="p">.</span><span class="n">addMouseListener</span><span class="p">(</span><span class="k">object</span> <span class="err">: </span><span class="nc">MouseAdapter</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseClicked</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseEntered</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">})</span></code></pre>

<p>If a supertype has a constructor, appropriate constructor parameters must be passed to it.
Many supertypes may be specified as a comma-separated list after the colon:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">open</span> <span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">public</span> <span class="k">open</span> <span class="k">val</span> <span class="py">y</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">x</span>
<span class="p">}</span>

<span class="n">interface</span> <span class="n">B</span> <span class="p">{...}</span>

<span class="k">val</span> <span class="py">ab</span> <span class="p">=</span> <span class="k">object</span> <span class="err">: </span><span class="nc">A</span><span class="p">(</span><span class="m">1</span><span class="p">),</span> <span class="n">B</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="py">y</span> <span class="p">=</span> <span class="m">15</span>
<span class="p">}</span></code></pre>

<p>If, by any chance, we need “just an object”, with no nontrivial supertypes, we can simply say:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">adHoc</span> <span class="p">=</span> <span class="k">object</span> <span class="err">{</span>
  <span class="k">var</span> <span class="py">x</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
  <span class="k">var</span> <span class="py">y</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
<span class="p">}</span>
<span class="n">print</span><span class="p">(</span><span class="n">adHoc</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="n">adHoc</span><span class="p">.</span><span class="n">y</span><span class="p">)</span></code></pre>

<p>Just like Java’s anonymous inner classes, code in object expressions can access variables from the enclosing scope.
(Unlike Java, this is not restricted to final variables.)</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">countClicks</span><span class="p">(</span><span class="n">window</span><span class="p">:</span> <span class="n">JComponent</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">var</span> <span class="py">clickCount</span> <span class="p">=</span> <span class="m">0</span>
  <span class="k">var</span> <span class="py">enterCount</span> <span class="p">=</span> <span class="m">0</span>

  <span class="n">window</span><span class="p">.</span><span class="n">addMouseListener</span><span class="p">(</span><span class="k">object</span> <span class="err">: </span><span class="nc">MouseAdapter</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseClicked</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">clickCount</span><span class="p">++</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseEntered</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">enterCount</span><span class="p">++</span>
    <span class="p">}</span>
  <span class="p">})</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<h2 id="object-declarations">Object declarations<a href="#object-declarations" class="anchor"></a></h2>

<p><a href="http://en.wikipedia.org/wiki/Singleton_pattern">Singleton</a> is a very useful pattern, and Kotlin (after Scala) makes it easy to declare singletons:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">object</span> <span class="nc">DataProviderManager</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">registerDataProvider</span><span class="p">(</span><span class="n">provider</span><span class="p">:</span> <span class="n">DataProvider</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">val</span> <span class="py">allDataProviders</span> <span class="p">:</span> <span class="n">Collection</span><span class="p">&lt;</span><span class="n">DataProvider</span><span class="p">&gt;</span>
    <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>This is called an <em>object declaration</em>. If there’s a name following the <em class="keyword">object</em> keyword, we are not talking about an <em>expression</em> anymore.
We cannot assign such a thing to a variable, but we can refer to it by its name. Such objects can have supertypes:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">object</span> <span class="nc">DefaultListener</span> <span class="p">:</span> <span class="n">MouseAdapter</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseClicked</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>

  <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseEntered</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p><strong>NOTE</strong>: object declarations can’t be local (i.e. be nested in directly inside a function), but they can be nested into other object declarations or non-inner classes.</p>

<h3 id="companion-objects">Companion Objects<a href="#companion-objects" class="anchor"></a></h3>

<p>An object declaration inside a class can be marked with the <em class="keyword">companion</em> keyword:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="n">companion</span> <span class="k">object</span> <span class="nc">Factory</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">create</span><span class="p">():</span> <span class="n">MyClass</span> <span class="p">=</span> <span class="n">MyClass</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Members of the companion object can be called by using simply the class name as the qualifier:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">instance</span> <span class="p">=</span> <span class="n">MyClass</span><span class="p">.</span><span class="n">create</span><span class="p">()</span></code></pre>

<p>The name of the companion object can be omitted, in which case the name <code>Companion</code> will be used:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="n">companion</span> <span class="k">object</span> <span class="err">{</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">val</span> <span class="py">x</span> <span class="p">=</span> <span class="n">MyClass</span><span class="p">.</span><span class="n">Companion</span></code></pre>

<p>Note that, even though the members of companion objects look like static members in other languages, at runtime those
are still instance members of real objects, and can, for example, implement interfaces:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">interface</span> <span class="n">Factory</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">create</span><span class="p">():</span> <span class="n">T</span>
<span class="p">}</span>


<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="n">companion</span> <span class="k">object</span> <span class="err">: </span><span class="nc">Factory</span><span class="p">&lt;</span><span class="n">MyClass</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">create</span><span class="p">():</span> <span class="n">MyClass</span> <span class="p">=</span> <span class="n">MyClass</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>However, on the JVM you can have members of companion objects generated as real static methods and fields, if you use
the <code>@platformStatic</code> annotation. See the <a href="java-interop.html#static-methods-and-fields">Java interoperability</a> section
for more details.</p>

<h3 id="semantical-difference-between-object-expressions-and-declarations">Semantical difference between object expressions and declarations<a href="#semantical-difference-between-object-expressions-and-declarations" class="anchor"></a></h3>

<p>There is one important semantical difference between object expressions and object declarations:</p>

<ul>
  <li>object declarations are initialized <strong>lazily</strong>, when accessed for the first time</li>
  <li>object expressions are executed (and initialized) <strong>immediately</strong>, where they are used</li>
</ul>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/delegation.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="delegation">Delegation<a href="#delegation" class="anchor"></a></h1>

<h2 id="class-delegation">Class Delegation<a href="#class-delegation" class="anchor"></a></h2>

<p>The <a href="https://en.wikipedia.org/wiki/Delegation_pattern">Delegation pattern</a> has proven to be a good alternative to implementation inheritance,
and Kotlin supports it natively requiring zero boilerplate code.
A class <code>Derived</code> can inherit from an interface <code>Base</code> and delegate all of its public methods to a specified object:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">interface</span> <span class="n">Base</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">print</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">BaseImpl</span><span class="p">(</span><span class="k">val</span> <span class="py">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Base</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="n">Base</span><span class="p">)</span> <span class="p">:</span> <span class="n">Base</span> <span class="k">by</span> <span class="n">b</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">b</span> <span class="p">=</span> <span class="n">BaseImpl</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
  <span class="n">Derived</span><span class="p">(</span><span class="n">b</span><span class="p">).</span><span class="n">print</span><span class="p">()</span> <span class="c1">// prints 10</span>
<span class="p">}</span></code></pre>

<p>The <em class="keyword">by</em>-clause in the supertype list for <code>Derived</code> indicates that <code>b</code> will be stored internally in objects of <code>Derived</code>
and the compiler will generate all the methods of <code>Base</code> that forward to <code>b</code>.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/delegated-properties.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="delegated-properties">Delegated Properties<a href="#delegated-properties" class="anchor"></a></h1>

<p>There are certain common kinds of properties, that, though we can implement them manually every time we need them, 
would be very nice to implement once and for all, and put into a library. Examples include</p>

<ul>
  <li>lazy properties: the value gets computed only upon first access,</li>
  <li>observable properties: listeners get notified about changes to this property,</li>
  <li>storing properties in a map, not in separate field each.</li>
</ul>

<p>To cover these (and other) cases, Kotlin supports <em>delegated properties</em>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Example</span> <span class="p">{</span>
  <span class="k">var</span> <span class="py">p</span><span class="p">:</span> <span class="n">String</span> <span class="k">by</span> <span class="n">Delegate</span><span class="p">()</span>
<span class="p">}</span></code></pre>

<p>The syntax is: <code>val/var &lt;property name&gt;: &lt;Type&gt; by &lt;expression&gt;</code>. The expression after <em class="keyword">by</em> is the <em>delegate</em>, 
because <code>get()</code> (and <code>set()</code>) corresponding to the property will be delegated to it.<br />
Property delegates don’t have to implement any interface, but they have to provide a <code>get()</code> function (and <code>set()</code> — for <em class="keyword">var</em>’s). 
For example:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Delegate</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">get</span><span class="p">(</span><span class="n">thisRef</span><span class="p">:</span> <span class="n">Any</span><span class="p">?,</span> <span class="n">prop</span><span class="p">:</span> <span class="n">PropertyMetadata</span><span class="p">):</span> <span class="n">String</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;$thisRef, thank you for delegating &#39;${prop.name}&#39; to me!&quot;</span>
  <span class="p">}</span>
 
  <span class="k">fun</span> <span class="nf">set</span><span class="p">(</span><span class="n">thisRef</span><span class="p">:</span> <span class="n">Any</span><span class="p">?,</span> <span class="n">prop</span><span class="p">:</span> <span class="n">PropertyMetadata</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;$value has been assigned to &#39;${prop.name} in $thisRef.&#39;&quot;</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>When we read from <code>p</code> that delegates to an instance of <code>Delegate</code>, the <code>get()</code> function from <code>Delegate</code> is called, 
so that its first parameter is the object we read <code>p</code> from and the second parameter holds a description of <code>p</code> itself 
(e.g. you can take its name). For example:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">e</span> <span class="p">=</span> <span class="n">Example</span><span class="p">()</span>
<span class="n">println</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">p</span><span class="p">)</span></code></pre>

<p>This prints </p>

<pre>Example@33a17727, thank you for delegating ‘p’ to me!
</pre>

<p>Similarly, when we assign to <code>p</code>, the <code>set()</code> function is called. The first two parameters are the same, and the third holds the value being assigned:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">e</span><span class="p">.</span><span class="n">p</span> <span class="p">=</span> <span class="s">&quot;NEW&quot;</span></code></pre>

<p>This prints</p>

<pre>NEW has been assigned to ‘p’ in Example@33a17727.
</pre>

<h2 id="property-delegate-requirements">Property Delegate Requirements<a href="#property-delegate-requirements" class="anchor"></a></h2>

<p>Here we summarize requirements to delegate objects. </p>

<p>For a <strong>read-only</strong> property (i.e. a <em class="keyword">val</em>), a delegate has to provide a function named <code>get</code> that takes the following parameters:</p>

<ul>
  <li>receiver — must be the same or a supertype of the <em>property owner</em> (for extension properties — the type being extended),</li>
  <li>metadata — must be of type <code>PropertyMetadata</code> or its supertype,</li>
</ul>

<p>this function must return the same type as property (or its subtype).</p>

<p>For a <strong>mutable</strong> property (a <em class="keyword">var</em>), a delegate has to <em>additionally</em> provide a function named <code>set</code> that takes the following parameters:</p>

<ul>
  <li>receiver — same as for <code>get()</code>,</li>
  <li>metadata — same as for <code>get()</code>,</li>
  <li>new value — must be of the same type as a property or its subtype.</li>
</ul>

<h2 id="standard-delegates">Standard Delegates<a href="#standard-delegates" class="anchor"></a></h2>

<p>The <code>kotlin.properties.Delegates</code> object from the standard library provides factory methods for several useful kinds of delegates.</p>

<h3 id="lazy">Lazy<a href="#lazy" class="anchor"></a></h3>

<p><code>Delegates.lazy()</code> is a function that takes a lambda and returns a delegate that implements a lazy property: 
the first call to <code>get()</code> executes the lambda passed to <code>lazy()</code> and remembers the result, 
subsequent calls to <code>get()</code> simply return the remembered result. </p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">import</span> <span class="nn">kotlin.properties.Delegates</span>
 
<span class="k">val</span> <span class="py">lazy</span><span class="p">:</span> <span class="n">String</span> <span class="k">by</span> <span class="n">Delegates</span><span class="p">.</span><span class="n">lazy</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="s">&quot;computed!&quot;</span><span class="p">)</span>
    <span class="s">&quot;Hello&quot;</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="n">lazy</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">lazy</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>If you want <strong>thread safety</strong>, use <code>blockingLazy()</code>: it works the same way, but guarantees that the values will be 
computed only in one thread, and that all threads will see the same value.</p>

<h3 id="observable">Observable<a href="#observable" class="anchor"></a></h3>

<p><code>Delegates.observable()</code> takes two arguments: initial value and a handler for modifications. 
The handler gets called every time we assign to the property (before the assignment is performed). It has three
parameters: a property being assigned to, the old value and the new one:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
    <span class="k">var</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span> <span class="k">by</span> <span class="n">Delegates</span><span class="p">.</span><span class="n">observable</span><span class="p">(</span><span class="s">&quot;&lt;no name&gt;&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span> <span class="p">-&gt;</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;$old -&gt; $new&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">user</span> <span class="p">=</span> <span class="n">User</span><span class="p">()</span>
    <span class="n">user</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="s">&quot;first&quot;</span>
    <span class="n">user</span><span class="p">.</span><span class="n">name</span> <span class="p">=</span> <span class="s">&quot;second&quot;</span>
<span class="p">}</span></code></pre>

<p>This example prints</p>

<pre>&lt;no name&gt; -&gt; first
first -&gt; second
</pre>

<p>If you want to be able to intercept an assignment and “veto” it, use <code>vetoable()</code> instead of <code>observable()</code>.</p>

<h3 id="not-null">Not-Null<a href="#not-null" class="anchor"></a></h3>

<p>Sometimes we have a non-null <em class="keyword">var</em>, but we don’t have an appropriate value to assign to it in the constructor, 
i.e. it must be assigned later. The problem is that you can’t have an uninitialized non-abstract property in Kotlin:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="k">var</span> <span class="py">bar</span><span class="p">:</span> <span class="n">Bar</span> <span class="c1">// ERROR: must be initialized</span>
<span class="p">}</span></code></pre>

<p>We could initialize it with <em class="keyword">null</em>, but then we’d have to check every time we access it.</p>

<p><code>Delegates.notNull()</code> can solve this problem:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="k">var</span> <span class="py">bar</span><span class="p">:</span> <span class="n">Bar</span> <span class="k">by</span> <span class="n">Delegates</span><span class="p">.</span><span class="n">notNull</span><span class="p">()</span>
<span class="p">}</span></code></pre>

<p>If this property is read before being written to for the first time, it throws an exception, after the first assignment it works as expected.</p>

<h3 id="storing-properties-in-a-map">Storing Properties in a Map<a href="#storing-properties-in-a-map" class="anchor"></a></h3>

<p><code>Delegates.mapVal()</code> takes a map instance and returns a delegate that reads property values from this map, using property name as a key.
There are many use cases of this kind in applications like parsing JSON or doing other “dynamic” things:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="k">val</span> <span class="py">map</span><span class="p">:</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Any</span><span class="p">?&gt;)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span> <span class="k">by</span> <span class="n">Delegates</span><span class="p">.</span><span class="n">mapVal</span><span class="p">(</span><span class="n">map</span><span class="p">)</span>
    <span class="k">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span>     <span class="k">by</span> <span class="n">Delegates</span><span class="p">.</span><span class="n">mapVal</span><span class="p">(</span><span class="n">map</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p>In this example, the constructor takes a map:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">user</span> <span class="p">=</span> <span class="n">User</span><span class="p">(</span><span class="n">mapOf</span><span class="p">(</span>
    <span class="s">&quot;name&quot;</span> <span class="n">to</span> <span class="s">&quot;John Doe&quot;</span><span class="p">,</span>
    <span class="s">&quot;age&quot;</span>  <span class="n">to</span> <span class="m">25</span>
<span class="p">))</span></code></pre>

<p>Delegates take values from this map (by the string keys – names of properties):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">println</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">name</span><span class="p">)</span> <span class="c1">// Prints &quot;John Doe&quot;</span>
<span class="n">println</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">age</span><span class="p">)</span>  <span class="c1">// Prints 25</span></code></pre>

<p>For <em class="keyword">var</em>’s we can use <code>mapVar()</code> (note that it takes a <code>MutableMap</code> instead of read-only <code>Map</code>).</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/functions.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="functions">Functions<a href="#functions" class="anchor"></a></h1>

<h2 id="function-declarations">Function Declarations<a href="#function-declarations" class="anchor"></a></h2>

<p>Functions in Kotlin are declared using the <em class="keyword">fun</em> keyword</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
<span class="p">}</span></code></pre>

<h3 id="parameters">Parameters<a href="#parameters" class="anchor"></a></h3>

<p>Function parameters are defined using Pascal notation, i.e. <em>name</em>: <em>type</em>. Parameters are separated using commas. Each parameter must be explicitly typed.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">powerOf</span><span class="p">(</span><span class="n">number</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">exponent</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span></code></pre>

<h3 id="default-arguments">Default Arguments<a href="#default-arguments" class="anchor"></a></h3>

<p>Function parameters can have default values, which are used when a corresponding argument is omitted. This allows for a reduced number of overloads compared to
other languages.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">read</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Byte</span><span class="p">&gt;,</span> <span class="n">off</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">len</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span></code></pre>

<p>Default values are defined using the <strong>=</strong> after type along with the value.</p>

<h3 id="named-arguments">Named Arguments<a href="#named-arguments" class="anchor"></a></h3>

<p>Function parameters can be named when calling functions. This is very convenient when a function has a high number of parameters or default ones.</p>

<p>Given the following function</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">reformat</span><span class="p">(</span><span class="n">str</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
             <span class="n">normalizeCase</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>
             <span class="n">upperCaseFirstLetter</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>
             <span class="n">divideByCamelHumps</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
             <span class="n">wordSeparator</span><span class="p">:</span> <span class="n">Char</span> <span class="p">=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span></code></pre>

<p>we could call this using default arguments</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">reformat</span><span class="p">(</span><span class="n">str</span><span class="p">)</span></code></pre>

<p>However, when calling it with non-default, the call would look something like</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">reformat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span></code></pre>

<p>With named arguments we can make the code much more readable</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">reformat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span>
    <span class="n">normalizeCase</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>
    <span class="n">uppercaseFirstLetter</span> <span class="p">=</span> <span class="k">true</span><span class="p">,</span>
    <span class="n">divideByCamelHumps</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
    <span class="n">wordSeparator</span> <span class="p">=</span> <span class="sc">&#39;_&#39;</span>
  <span class="p">)</span></code></pre>

<p>and if we do not need all arguments</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">reformat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">wordSeparator</span> <span class="p">=</span> <span class="sc">&#39;_&#39;</span><span class="p">)</span></code></pre>

<h3 id="unit-returning-functions">Unit-returning functions<a href="#unit-returning-functions" class="anchor"></a></h3>

<p>If a function does not return any useful value, its return type is <code>Unit</code>. <code>Unit</code> is a type with only one value - <code>Unit</code>. This
value does not have to be returned explicitly</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">printHello</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">?):</span> <span class="n">Unit</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello ${name}&quot;</span><span class="p">)</span>
    <span class="k">else</span>
        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hi there!&quot;</span><span class="p">)</span>
    <span class="c1">// `return Unit` or `return` is optional</span>
<span class="p">}</span></code></pre>

<p>The <code>Unit</code> return type declaration is also optional. The above code is equivalent to</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">printHello</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">?)</span> <span class="p">{</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>

<h3 id="single-expression-functions">Single-Expression functions<a href="#single-expression-functions" class="anchor"></a></h3>

<p>When a function returns a single expression, the curly braces can be omitted and the body is specified after a <strong>=</strong> symbol</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">x</span> <span class="p">*</span> <span class="m">2</span></code></pre>

<p>Explicitly declaring the return type is <a href="#explicit-return-types">optional</a> when this can be inferred by the compiler</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span> <span class="p">*</span> <span class="m">2</span></code></pre>

<h3 id="explicit-return-types">Explicit return types<a href="#explicit-return-types" class="anchor"></a></h3>

<p>There are cases when an explicit return type is required:</p>

<ul>
  <li>Functions with expression body that are public or protected. These are considered to be part of the public API surface. Not having explicit return types makes it potentially easier to
change the type accidentally. This is the same reason why explicit types are required for <a href="properties.html#getters-and-setters">properties</a>.</li>
  <li>Functions with block body must always specify return types explicitly, unless it’s intended for them to return <code>Unit</code>, <a href="#unit-returning-functions">in which case it is optional</a>. 
Kotlin does not infer return types for functions with block bodies because such functions may have complex control flow in the body, and the return
type will be non-obvious to the reader (and sometimes even for the compiler). </li>
</ul>

<h3 id="variable-number-of-arguments-varargs">Variable number of arguments (Varargs)<a href="#variable-number-of-arguments-varargs" class="anchor"></a></h3>

<p>The last parameter of a function may be marked with <code>vararg</code> annotation</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">asList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">vararg</span> <span class="n">ts</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="n">ArrayList</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;()</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="k">in</span> <span class="n">ts</span><span class="p">)</span> <span class="c1">// ts is an Array</span>
    <span class="n">result</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span></code></pre>

<p>allowing a variable number of arguments to be passed to the function:</p>

<pre><code class="code-block _highlighted lang_kotlin">  <span class="k">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">asList</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span></code></pre>

<p>Inside a function a <code>vararg</code>-parameter of type <code>T</code> is visible as an array of <code>T</code>, i.e. the <code>ts</code> variable in the example above has type <code>Array&lt;out T&gt;</code>.</p>

<p>Only one parameter may be annotated as <code>vararg</code>. It may be the last parameter or the one before last,
if the last parameter has a function type (allowing a lambda to be passed outside parentheses).</p>

<p>When we call a <code>vararg</code>-function, we can pass arguments one-by-one, e.g. <code>asList(1, 2, 3)</code>, or, if we already have an array
 and want to pass its contents to the function, we use the <strong>spread</strong> operator (prefix the array with <code>*</code>):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">array</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
<span class="k">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">asList</span><span class="p">(-</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="p">*</span><span class="n">a</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span></code></pre>

<h2 id="function-scope">Function Scope<a href="#function-scope" class="anchor"></a></h2>

<p>In Kotlin functions can be declared at top level in a file, meaning you do not need to create a class to hold a function, like languages such as Java, C# or Scala. In addition
to top level functions, Kotlin functions can also be declared local, as member functions and extension functions.</p>

<h3 id="local-functions">Local Functions<a href="#local-functions" class="anchor"></a></h3>

<p>Kotlin supports local functions, i.e. a function inside another function</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">current</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span> <span class="n">visited</span><span class="p">:</span> <span class="n">Set</span><span class="p">&lt;</span><span class="n">Vertex</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="k">return</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="k">in</span> <span class="n">current</span><span class="p">.</span><span class="n">neighbors</span><span class="p">)</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">HashSet</span><span class="p">())</span>
<span class="p">}</span></code></pre>

<p>Local function can access local variables of outer functions (i.e. the closure), so in the case above, the <em>visited</em> can be a local variable</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">Graph</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">visited</span> <span class="p">=</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">Vertex</span><span class="p">&gt;()</span>
  <span class="k">fun</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">current</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="k">return</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="k">in</span> <span class="n">current</span><span class="p">.</span><span class="n">neighbors</span><span class="p">)</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">vertices</span><span class="p">[</span><span class="m">0</span><span class="p">])</span>
<span class="p">}</span></code></pre>

<p>Local functions can even return from outer functions using <a href="returns.html">qualified return expressions</a></p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">reachable</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">,</span> <span class="n">to</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">):</span> <span class="n">Boolean</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">visited</span> <span class="p">=</span> <span class="n">HashSet</span><span class="p">&lt;</span><span class="n">Vertex</span><span class="p">&gt;()</span>
  <span class="k">fun</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">current</span><span class="p">:</span> <span class="n">Vertex</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// here we return from the outer function:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="p">==</span> <span class="n">to</span><span class="p">)</span> <span class="k">return</span><span class="n">@reachable</span> <span class="k">true</span>
    <span class="c1">// And here -- from local function:</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="k">return</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">v</span> <span class="k">in</span> <span class="n">current</span><span class="p">.</span><span class="n">neighbors</span><span class="p">)</span>
      <span class="n">dfs</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="n">dfs</span><span class="p">(</span><span class="n">from</span><span class="p">)</span>
  <span class="k">return</span> <span class="k">false</span> <span class="c1">// if dfs() did not return true already</span>
<span class="p">}</span></code></pre>

<h3 id="member-functions">Member Functions<a href="#member-functions" class="anchor"></a></h3>

<p>A member function is a function that is defined inside a class or object</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Sample</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;Foo&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Member functions are called with dot notation</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">Sample</span><span class="p">().</span><span class="n">foo</span><span class="p">()</span> <span class="c1">// creates instance of class Sample and calls foo</span></code></pre>

<p>For more information on classes and overriding members see <a href="classes.html">Classes</a> and <a href="classes.html#inheritance">Inheritance</a></p>

<h3 id="generic-functions">Generic Functions<a href="#generic-functions" class="anchor"></a></h3>

<p>Functions can have generic parameters which are specified using angle brackets after the function name and before the value parameters</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">singletonArray</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">,</span> <span class="p">{</span><span class="n">item</span><span class="p">})</span>
<span class="p">}</span></code></pre>

<p>For more information on generic functions see <a href="generics.html">Generics</a></p>

<h3 id="inline-functions">Inline Functions<a href="#inline-functions" class="anchor"></a></h3>

<p>Inline functions are explained <a href="inline-functions.html">here</a></p>

<h3 id="extension-functions">Extension Functions<a href="#extension-functions" class="anchor"></a></h3>

<p>Extension functions are explained in <a href="extensions.html">their own section</a></p>

<h3 id="higher-order-functions-and-lambdas">Higher-Order Functions and Lambdas<a href="#higher-order-functions-and-lambdas" class="anchor"></a></h3>

<p>Higher-Order functions and Lambdas are explained in <a href="lambdas.html">their own section</a></p>

<h2 id="function-usage">Function Usage<a href="#function-usage" class="anchor"></a></h2>

<p>Calling functions uses the traditional approach</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="n">double</span><span class="p">(</span><span class="m">2</span><span class="p">)</span></code></pre>

<p>Calling member functions uses the dot notation</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">Sample</span><span class="p">().</span><span class="n">foo</span><span class="p">()</span> <span class="c1">// create instance of class Sample and calls foo</span></code></pre>

<h3 id="infix-notation">Infix notation<a href="#infix-notation" class="anchor"></a></h3>

<p>Functions can also be called using infix notations when</p>

<ul>
  <li>They are member functions or <a href="extensions.html">extension functions</a></li>
  <li>They have a single parameter</li>
</ul>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// Define extension to Int</span>
<span class="k">fun</span> <span class="nf">Int</span><span class="p">.</span><span class="n">shl</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="c1">// call extension function using infix notation</span>

<span class="m">1</span> <span class="n">shl</span> <span class="m">2</span>

<span class="c1">// is the same as</span>

<span class="m">1.</span><span class="n">shl</span><span class="p">(</span><span class="m">2</span><span class="p">)</span></code></pre>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/lambdas.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="higher-order-functions-and-lambdas">Higher-Order Functions and Lambdas<a href="#higher-order-functions-and-lambdas" class="anchor"></a></h1>

<h2 id="higher-order-functions">Higher-Order Functions<a href="#higher-order-functions" class="anchor"></a></h2>

<p>A higher-order function is a function that takes functions as parameters, or returns a function.
A good example of such a function is <code>lock()</code> that takes a lock object and a function, acquires the lock, runs the function and releases the lock:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">lock</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">lock</span><span class="p">:</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">):</span> <span class="n">T</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">body</span><span class="p">()</span>
  <span class="p">}</span>
  <span class="k">finally</span> <span class="p">{</span>
    <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Let’s examine the code above: <code>body</code> has a <a href="#function-types">function type</a>: <code>() -&gt; T</code>,
so it’s supposed to be a function that takes no parameters and returns a value of type <code>T</code>.
It is invoked inside the <em class="keyword">try</em>-block, while protected by the <code>lock</code>, and its result is returned by the <code>lock()</code> function.</p>

<p>If we want to call <code>lock()</code>, we can pass another function to it as an argument (see <a href="reflection.html#function-references">function references</a>):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">toBeSynchronized</span><span class="p">()</span> <span class="p">=</span> <span class="n">sharedResource</span><span class="p">.</span><span class="n">operation</span><span class="p">()</span>

<span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="n">lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="o">::</span><span class="n">toBeSynchronized</span><span class="p">)</span></code></pre>

<p>Another, often more convenient way is to pass a <a href="#function-literals-and-function-expressions">function literal</a> (often referred to as <em>lambda expression</em>):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="n">lock</span><span class="p">(</span><span class="n">lock</span><span class="p">,</span> <span class="p">{</span> <span class="n">sharedResource</span><span class="p">.</span><span class="n">operation</span><span class="p">()</span> <span class="p">})</span></code></pre>

<p>Function literals are described in more <a href="#function-literals-and-function-expressions">detail below</a>, but for purposes of continuing this section, let’s see a brief overview:</p>

<ul>
  <li>A function literal is always surrounded by curly braces,</li>
  <li>Its parameters (if any) are declared before <code>-&gt;</code> (parameter types may be omitted),</li>
  <li>The body goes after <code>-&gt;</code> (when present).</li>
</ul>

<p>In Kotlin, there is a convention that if the last parameter to a function is a function, then we can omit the parentheses</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">lock</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">sharedResource</span><span class="p">.</span><span class="n">operation</span><span class="p">()</span>
<span class="p">}</span></code></pre>

<p>Another example of a higher-order function would be <code>map()</code> (of <a href="http://en.wikipedia.org/wiki/MapReduce">MapReduce</a>):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">,</span> <span class="n">R</span><span class="p">&gt;</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.</span><span class="n">map</span><span class="p">(</span><span class="n">transform</span><span class="p">:</span> <span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">R</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">result</span> <span class="p">=</span> <span class="n">arrayListOf</span><span class="p">&lt;</span><span class="n">R</span><span class="p">&gt;()</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">item</span> <span class="k">in</span> <span class="k">this</span><span class="p">)</span>
    <span class="n">result</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">transform</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span></code></pre>

<p>This function can be called as follows:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">doubled</span> <span class="p">=</span> <span class="n">ints</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span><span class="n">it</span> <span class="p">-&gt;</span> <span class="n">it</span> <span class="p">*</span> <span class="m">2</span><span class="p">}</span></code></pre>

<p>One other helpful convention is that if a function literal has only one parameter,
its declaration may be omitted (along with the <code>-&gt;</code>), and its name will be <code>it</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">ints</span> <span class="n">map</span> <span class="p">{</span><span class="n">it</span> <span class="p">*</span> <span class="m">2</span><span class="p">}</span> <span class="c1">// Infix call + Implicit &#39;it&#39;</span></code></pre>

<p>These conventions allow to write <a href="http://msdn.microsoft.com/en-us/library/bb308959.aspx">LINQ-style</a> code:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">strings</span> <span class="n">filter</span> <span class="p">{</span><span class="n">it</span><span class="p">.</span><span class="n">length</span> <span class="p">==</span> <span class="m">5</span><span class="p">}</span> <span class="n">sortBy</span> <span class="p">{</span><span class="n">it</span><span class="p">}</span> <span class="n">map</span> <span class="p">{</span><span class="n">it</span><span class="p">.</span><span class="n">toUpperCase</span><span class="p">()}</span></code></pre>

<h2 id="inline-functions">Inline Functions<a href="#inline-functions" class="anchor"></a></h2>

<p>Sometimes it is beneficial to enhance performance of higher-order functions using <a href="inline-functions.html">inline functions</a>.</p>

<h2 id="function-literals-and-function-expressions">Function Literals and Function Expressions<a href="#function-literals-and-function-expressions" class="anchor"></a></h2>

<p>A function literal or a function expression is an “anonymous function”, i.e. a function that is not declared,
but passed immediately as an expression. Consider the following example:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">max</span><span class="p">(</span><span class="n">strings</span><span class="p">,</span> <span class="p">{</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="p">-&gt;</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span> <span class="p">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">})</span></code></pre>

<p>Function <code>max</code> is a higher-order function, i.e. it takes a function value as the second argument.
This second argument is an expression that is itself a function, i.e. a function literal. As a function, it is equivalent to</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">compare</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span> <span class="p">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span></code></pre>

<h3 id="function-types">Function Types<a href="#function-types" class="anchor"></a></h3>

<p>For a function to accept another function as a parameter, we have to specify a function type for that parameter.
For example the abovementioned function <code>max</code> is defined as follows:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">max</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">collection</span><span class="p">:</span> <span class="n">Collection</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">&gt;,</span> <span class="n">less</span><span class="p">:</span> <span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Boolean</span><span class="p">):</span> <span class="n">T</span><span class="p">?</span> <span class="p">{</span>
  <span class="k">var</span> <span class="py">max</span><span class="p">:</span> <span class="n">T</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">it</span> <span class="k">in</span> <span class="n">collection</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">less</span><span class="p">(</span><span class="n">max</span><span class="o">!!</span><span class="p">,</span> <span class="n">it</span><span class="p">))</span>
      <span class="n">max</span> <span class="p">=</span> <span class="n">it</span>
  <span class="k">return</span> <span class="n">max</span>
<span class="p">}</span></code></pre>

<p>The parameter <code>less</code> is of type <code>(T, T) -&gt; Boolean</code>, i.e. a function that takes two parameters of type <code>T</code> and returns a <code>Boolean</code>:
true if the first one is smaller than the second one.</p>

<p>In the body, line 4, <code>less</code> is used as a function: it is called by passing two arguments of type <code>T</code>.</p>

<p>A function type is written as above, or may have named parameters, for documentation purposes and
to enable calls with <a href="functions.html#named-arguments">named arguments</a>.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">compare</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="p">=</span> <span class="p">...</span></code></pre>

<h3 id="function-literal-syntax">Function Literal Syntax<a href="#function-literal-syntax" class="anchor"></a></h3>

<p>The full syntactic form of function literals, i.e. literals of function types, is as follows:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">sum</span> <span class="p">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span><span class="p">}</span></code></pre>

<p>A function literal is always surrounded by curly braces,
parameter declarations in the full syntactic form go inside parentheses and have optional type annotations,
the body goes after an <code>-&gt;</code> sign.
If we leave all the optional annotations out, what’s left looks like this:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">sum</span><span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Int</span> <span class="p">=</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="p">-&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span><span class="p">}</span></code></pre>

<p>It’s very common that a function literal has only one parameter.
If Kotlin can figure the signature out itself, it allows us not to declare the only parameter, and will implicitly
declare it for us under the name <code>it</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">ints</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span><span class="n">it</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">}</span> <span class="c1">// this literal is of type &#39;(it: Int) -&gt; Boolean&#39;</span></code></pre>

<p>Note that if a function takes another function as the last parameter, the function literal argument can be passed
outside the parenthesized argument list.
See the grammar for <a href="grammar.html#call-suffix">callSuffix</a>.</p>

<h3 id="function-expressions">Function Expressions<a href="#function-expressions" class="anchor"></a></h3>

<p>One thing missing from the function literal syntax presented above is the ability to specify the return type of the
function. In most cases, this is unnecessary because the return type can be inferred automatically. However, if you
do need to specify it explicitly, you can use an alternative syntax: a <em>function expression</em>.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span></code></pre>

<p>A function expression looks very much like a regular function declaration, except that its name is omitted. Its body
can be either an expression (as shown above) or a block:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span>
<span class="p">}</span></code></pre>

<p>The parameters and the return type are specified in the same way as for regular functions, except that the parameter
types can be omitted if they can be inferred from context:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">ints</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="k">fun</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">=</span> <span class="n">item</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span></code></pre>

<p>The return type inference for function expressions works just like for normal functions: the return type is inferred
automatically for function expressions with an expression body and has to be specified explicitly (or is assumed to be
<code>Unit</code>) for function expressions with a block body.</p>

<p>Note that function expression parameters are always passed inside the parentheses. The shorthand syntax allowing
to leave the function outside the parentheses works only for function literals.</p>

<p>One other difference between function literals and function expressions is the behavior of
<a href="inline-functions.html#non-local-returns">non-local returns</a>. A <em class="keyword">return</em>  statement without a label
always returns from the function declared with the <em class="keyword">fun</em> keyword. This means that a <em class="keyword">return</em>
inside a function literal will return from the enclosing function, whereas a <em class="keyword">return</em> inside
a function expression will return from the function expression itself.</p>

<h3 id="closures">Closures<a href="#closures" class="anchor"></a></h3>

<p>A function literal or expression (as well as a <a href="functions.html#local-functions">local function</a> and an <a href="object-declarations.html#object-expressions">object expression</a>)
can access its <em>closure</em>, i.e. the variables declared in the outer scope. Unlike Java, the variables captured in the closure can be modified:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="py">sum</span> <span class="p">=</span> <span class="m">0</span>
<span class="n">ints</span> <span class="n">filter</span> <span class="p">{</span><span class="n">it</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">}</span> <span class="n">forEach</span> <span class="p">{</span>
  <span class="n">sum</span> <span class="p">+=</span> <span class="n">it</span>
<span class="p">}</span>
<span class="n">print</span><span class="p">(</span><span class="n">sum</span><span class="p">)</span></code></pre>

<h3 id="extension-function-expressions">Extension Function Expressions<a href="#extension-function-expressions" class="anchor"></a></h3>

<p>In addition to ordinary functions, Kotlin supports extension functions.
This kind of functions is so useful that extension function literals and expressions are also supported.
One of the most important examples of their usage is <a href="type-safe-builders.html">Type-safe Groovy-style builders</a>.</p>

<p>An extension function expression differs from an ordinary one in that it has a receiver type specification.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">sum</span> <span class="p">=</span> <span class="k">fun</span> <span class="nf">Int</span><span class="p">.(</span><span class="n">other</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">=</span> <span class="k">this</span> <span class="p">+</span> <span class="n">other</span></code></pre>

<p>Receiver type may be specified explicitly only in function expressions, not in function literals. Function literals
can be used as extension function expressions, but only when the receiver type can be inferred from the context.</p>

<p>The type of an extension function expression is a function type with receiver:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">sum</span> <span class="p">:</span> <span class="n">Int</span><span class="p">.(</span><span class="n">other</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Int</span></code></pre>

<p>The function can be called with a dot or in infix form (since it has only one parameter):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="m">1.</span><span class="n">sum</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
<span class="m">1</span> <span class="n">sum</span> <span class="m">2</span></code></pre>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/inline-functions.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="inline-functions">Inline Functions<a href="#inline-functions" class="anchor"></a></h1>

<p>Using <a href="lambdas.html">higher-order functions</a> imposes certain runtime penalties: each function is an object, and it captures a closure,
i.e. those variables that are accessed in the body of the function.
Memory allocations (both for function objects and classes) and virtual calls introduce runtime overhead.</p>

<p>But it appears that in many cases this kind of overhead can be eliminated by inlining the function literals.
The functions shown above are good examples of this situation. I.e., the <code>lock()</code> function could be easily inlined at call-sites.
Consider the following case:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">lock</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span><span class="n">foo</span><span class="p">()}</span></code></pre>

<p>Instead of creating a function object for the parameter and generating a call, the compiler could emit the following code</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">lock</span><span class="p">.</span><span class="n">lock</span><span class="p">()</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">()</span>
<span class="p">}</span>
<span class="k">finally</span> <span class="p">{</span>
  <span class="n">lock</span><span class="p">.</span><span class="n">unlock</span><span class="p">()</span>
<span class="p">}</span></code></pre>

<p>Isn’t it what we wanted from the very beginning?</p>

<p>To make the compiler do this, we need to annotate the <code>lock()</code> function with the <code>inline</code> annotation:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">inline</span> <span class="k">fun</span> <span class="nf">lock</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">lock</span><span class="p">:</span> <span class="n">Lock</span><span class="p">,</span> <span class="n">body</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">):</span> <span class="n">T</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>The <code>inline</code> annotation affects both the function itself and the lambdas passed to it: all of those will be inlined
into the call site.</p>

<p>Inlining may cause the generated code to grow, but if we do it in a reasonable way (do not inline big functions)
it will pay off in performance, especially at “megamorphic” call-sites inside loops.</p>

<h2 id="noinline">@noinline<a href="#noinline" class="anchor"></a></h2>

<p>In case you want only some of the lambdas passed to an inline function to be inlined, you can mark some of your function
parameters with <code>@noinline</code> annotation:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">inline</span> <span class="k">fun</span> <span class="nf">foo</span><span class="p">(</span><span class="n">inlined</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">,</span> <span class="n">@noinline</span> <span class="n">notInlined</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>Inlinable lambdas can only be called inside the inline functions or passed as inlinable arguments,
but <code>@noinline</code> ones can be manipulated in any way we like: stored in fields, passed around etc.</p>

<p>Note that if an inline function has no inlinable function parameters and no
<a href="#reified-type-parameters">reified type parameters</a>, the compiler will issue a warning, since inlining such functions is
 very unlikely to be beneficial (you can suppress the warning if you are sure the inlining is needed).</p>

<h2 id="non-local-returns">Non-local returns<a href="#non-local-returns" class="anchor"></a></h2>

<p>In Kotlin, we can only use a normal, unqualified <code>return</code> to exit a named function or a function expression.
This means that to exit a lambda, we have to use a <a href="returns.html#return-at-labels">label</a>, and a bare <code>return</code> is forbidden
inside a lambda, because a lambda can not make the enclosing function return:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">ordinaryFunction</span> <span class="p">{</span>
     <span class="k">return</span> <span class="c1">// ERROR: can not make `foo` return here</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>But if the function the lambda is passed to is inlined, the return can be inlined as well, so it is allowed:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">inlineFunction</span> <span class="p">{</span>
    <span class="k">return</span> <span class="c1">// OK: the lambda is inlined</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Such returns (located in a lambda, but exiting the enclosing function) are called <em>non-local</em> returns. We are used to
this sort of constructs in loops, which inline functions often enclose:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">hasZeros</span><span class="p">(</span><span class="n">ints</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;):</span> <span class="n">Boolean</span> <span class="p">{</span>
  <span class="n">ints</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span> <span class="k">true</span> <span class="c1">// returns from hasZeros</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="k">false</span>
<span class="p">}</span></code></pre>

<p>Note that some inline functions may call the lambdas passed to them as parameters not directly from the function body,
but from another execution context, such as a local object or a nested function. In such cases, non-local control flow
is also not allowed in the lambdas. To indicate that, the lambda parameter needs to be annotated with
the <code>InlineOptions.ONLY_LOCAL_RETURN</code> annotation:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">inline</span> <span class="k">fun</span> <span class="nf">f</span><span class="p">(</span><span class="n">inlineOptions</span><span class="p">(</span><span class="n">InlineOption</span><span class="p">.</span><span class="n">ONLY_LOCAL_RETURN</span><span class="p">)</span> <span class="n">body</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">f</span> <span class="p">=</span> <span class="k">object</span><span class="p">:</span> <span class="n">Runnable</span> <span class="p">{</span>
        <span class="k">override</span> <span class="k">fun</span> <span class="nf">run</span><span class="p">()</span> <span class="p">=</span> <span class="n">body</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<blockquote>
  <p><code>break</code> and <code>continue</code> are not yet available in inlined lambdas, but we are planning to support them too</p>
</blockquote>

<h2 id="reified-type-parameters">Reified type parameters<a href="#reified-type-parameters" class="anchor"></a></h2>

<p>Sometimes we need to access a type passed to us as a parameter:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">TreeNode</span><span class="p">.</span><span class="n">findParentOfType</span><span class="p">(</span><span class="n">clazz</span><span class="p">:</span> <span class="n">Class</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;):</span> <span class="n">T</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">var</span> <span class="py">p</span> <span class="p">=</span> <span class="n">parent</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">clazz</span><span class="p">.</span><span class="n">isInstance</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">p</span> <span class="p">=</span> <span class="n">p</span><span class="o">?.</span><span class="n">parent</span>
    <span class="p">}</span>
    <span class="n">@suppress</span><span class="p">(</span><span class="s">&quot;UNCHECKED_CAST&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">p</span> <span class="k">as</span> <span class="n">T</span>
<span class="p">}</span></code></pre>

<p>Here, we walk up a tree and use reflection to check if a node has a certain type.
It’s all fine, but the call site is not very pretty:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">myTree</span><span class="p">.</span><span class="n">findParentOfType</span><span class="p">(</span><span class="n">javaClass</span><span class="p">&lt;</span><span class="n">MyTreeNodeType</span><span class="p">&gt;())</span></code></pre>

<p>What we actually want is simply pass a type to this function, i.e. call is like this:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">myTree</span><span class="p">.</span><span class="n">findParentOfType</span><span class="p">&lt;</span><span class="n">MyTreeNodeType</span><span class="p">&gt;()</span></code></pre>

<p>To enable this, inline functions support <em>reified type parameters</em>, so we can write something like this:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">TreeNode</span><span class="p">.</span><span class="n">findParentOfType</span><span class="p">():</span> <span class="n">T</span><span class="p">?</span> <span class="p">{</span>
    <span class="k">var</span> <span class="py">p</span> <span class="p">=</span> <span class="n">parent</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">p</span> <span class="p">!</span><span class="k">is</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span> <span class="p">=</span> <span class="n">p</span><span class="o">?.</span><span class="n">parent</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span> <span class="k">as</span> <span class="n">T</span>
<span class="p">}</span></code></pre>

<p>We qualified the type parameter with the reified modifier, now it’s accessible inside the function,
almost as if it were a normal class. Since the function is inlined, no reflection is needed, normal operators like <code>!is</code>
and <code>as</code> are working now. Also, we can call it as mentioned above: <code>myTree.findParentOfType&lt;MyTreeNodeType&gt;()</code>.</p>

<p>Though reflection may not be needed in many cases, we can still use it with a reified type parameter: <code>javaClass()</code> gives us access to it:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">inline</span> <span class="k">fun</span> <span class="nf">methodsOf</span><span class="p">&lt;</span><span class="k">reified</span> <span class="n">T</span><span class="p">&gt;()</span> <span class="p">=</span> <span class="n">javaClass</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;().</span><span class="n">getMethods</span><span class="p">()</span>

<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="n">println</span><span class="p">(</span><span class="n">methodsOf</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;().</span><span class="n">joinToString</span><span class="p">(</span><span class="s">&quot;\n&quot;</span><span class="p">))</span>
<span class="p">}</span></code></pre>

<p>Normal functions (not marked as inline) can not have reified parameters.
A type that does not have a run-time representation (e.g. a non-reified type parameter or a fictitious type like <code>Nothing</code>)
can not be used as an argument for a reified type parameter.</p>

<p>For a low-level description, see the <a href="https://github.com/JetBrains/kotlin/blob/master/spec-docs/reified-type-parameters.md">spec document</a>.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/multi-declarations.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="multi-declarations">Multi-Declarations<a href="#multi-declarations" class="anchor"></a></h1>

<p>Sometimes it is convenient to <em>decompose</em> an object into a number of variables, for example:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="err">(</span><span class="py">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="p">=</span> <span class="n">person</span></code></pre>

<p>This syntax is called a <em>multi-declaration</em>. A multi-declaration creates multiple variables at once.
We have declared two new variables: <code>name</code> and <code>age</code>, and can use them independently:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">println</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="n">age</span><span class="p">)</span></code></pre>

<p>A multi-declaration is compiled down to the following code:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">name</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">component1</span><span class="p">()</span>
<span class="k">val</span> <span class="py">age</span> <span class="p">=</span> <span class="n">person</span><span class="p">.</span><span class="n">component2</span><span class="p">()</span></code></pre>

<p>The <code>component1()</code> and <code>component2()</code> functions are another example of the <em>principle of conventions</em> widely used in Kotlin 
(see operators like <code>+</code> and <code>*</code>, <em class="keyword">for</em>-loops etc.). 
Anything can be on the right-hand side of a multi-assignment, as long as the required number of component functions can be called on it. 
And, of course, there can be <code>component3()</code> and <code>component4()</code> and so on.</p>

<p>Multi-declarations also work in <em class="keyword">for</em>-loops: when you say</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">in</span> <span class="n">collection</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span></code></pre>

<p>Variables <code>a</code> and <code>b</code> get the values returned by <code>component1()</code> and <code>component2()</code> called on elements of the collection. </p>

<h2 id="example-returning-two-values-from-a-function">Example: Returning Two Values from a Function<a href="#example-returning-two-values-from-a-function" class="anchor"></a></h2>

<p>Let’s say we need to return two things from a function. For example, a result object and a status of some sort.
A compact way of doing this in Kotlin is to declare a <a href="data-classes.html"><em>data class</em></a> and return its instance:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">data</span> <span class="k">class</span> <span class="nc">Result</span><span class="p">(</span><span class="k">val</span> <span class="py">result</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">val</span> <span class="py">status</span><span class="p">:</span> <span class="n">Status</span><span class="p">)</span>
<span class="k">fun</span> <span class="nf">function</span><span class="p">(...):</span> <span class="n">Result</span> <span class="p">{</span>
    <span class="c1">// computations</span>
    
    <span class="k">return</span> <span class="n">Result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Now, to use this function:</span>
<span class="k">val</span> <span class="err">(</span><span class="py">result</span><span class="p">,</span> <span class="n">status</span><span class="p">)</span> <span class="p">=</span> <span class="n">function</span><span class="p">(...)</span></code></pre>

<p>Since data classes automatically declare <code>componentN()</code> functions, multi-declarations work here.</p>

<p><strong>NOTE</strong>: we could also use the standard class <code>Pair</code> and have <code>function()</code> return <code>Pair&lt;Int, Status&gt;</code>, 
but it’s often better to have your data named properly.  </p>

<h2 id="example-multi-declarations-and-maps">Example: Multi-Declarations and Maps<a href="#example-multi-declarations-and-maps" class="anchor"></a></h2>

<p>Probably the nicest way to traverse a map is this:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">map</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// do something with the key and the value</span>
<span class="p">}</span></code></pre>

<p>To make this work, we should </p>

<ul>
  <li>present the map as sequence of values by providing an <code>iterator()</code> function,</li>
  <li>present each of the elements as a pair by providing functions <code>component1()</code> and <code>component2()</code>.</li>
</ul>

<p>And indeed, the standard library provides such extensions:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">K</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;.</span><span class="n">iterator</span><span class="p">():</span> <span class="n">Iterator</span><span class="p">&lt;</span><span class="n">Map</span><span class="p">.</span><span class="n">Entry</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;&gt;</span> <span class="p">=</span> <span class="n">entrySet</span><span class="p">().</span><span class="n">iterator</span><span class="p">()</span>
<span class="k">fun</span> <span class="err">&lt;</span><span class="nf">K</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;</span> <span class="n">Map</span><span class="p">.</span><span class="n">Entry</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;.</span><span class="n">component1</span><span class="p">()</span> <span class="p">=</span> <span class="n">getKey</span><span class="p">()</span>
<span class="k">fun</span> <span class="err">&lt;</span><span class="nf">K</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;</span> <span class="n">Map</span><span class="p">.</span><span class="n">Entry</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;.</span><span class="n">component2</span><span class="p">()</span> <span class="p">=</span> <span class="n">getValue</span><span class="p">()</span></code></pre>

<p>So you can freely use multi-declarations in <em class="keyword">for</em>-loops with maps (as well as collections of data class instances etc).</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/ranges.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="ranges">Ranges<a href="#ranges" class="anchor"></a></h1>

<p>Range expressions are formed with <code>rangeTo</code> functions that have the operator form of <code>..</code> which are complemented by <em class="keyword">in</em> and <em class="keyword">!in</em>.
Range is defined for any comparable type, but for number primitives it is optimized. Here are examples of using ranges</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">10</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// equivalent of 1 &lt;= i &amp;&amp; i &lt;= 10</span>
  <span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">!</span><span class="k">in</span> <span class="m">1.0</span><span class="p">..</span><span class="m">3.0</span><span class="p">)</span> <span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="k">in</span> <span class="s">&quot;island&quot;</span><span class="p">..</span><span class="s">&quot;isle&quot;</span><span class="p">)</span> <span class="n">println</span><span class="p">(</span><span class="n">str</span><span class="p">)</span></code></pre>

<p>Numerical ranges have an extra feature: they can be iterated over.
Compiler takes care about converting this in simple analogue of Java’s indexed <em class="keyword">for</em>-loop, without extra overhead. Examples</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">4</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;1234&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">4.</span><span class="p">.</span><span class="m">1</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints nothing</span>

<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="m">1.0</span><span class="p">..</span><span class="m">2.0</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;$x &quot;</span><span class="p">)</span> <span class="c1">// prints &quot;1.0 2.0 &quot;</span></code></pre>

<p>What if you want to iterate over numbers in reversed order? It’s simple. You can use <code>downTo()</code> function defined in standard library</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">4</span> <span class="n">downTo</span> <span class="m">1</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;4321&quot;</span></code></pre>

<p>Is it possible to iterate over numbers with arbitrary step, not equal to 1? Sure, <code>step()</code> function will help you</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">4</span> <span class="n">step</span> <span class="m">2</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;13&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">4</span> <span class="n">downTo</span> <span class="m">1</span> <span class="n">step</span> <span class="m">2</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;42&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.0</span><span class="p">..</span><span class="m">2.0</span> <span class="n">step</span> <span class="m">0.3</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;$i &quot;</span><span class="p">)</span> <span class="c1">// prints &quot;1.0 1.3 1.6 1.9 &quot;</span></code></pre>

<h2 id="how-it-works">How it works<a href="#how-it-works" class="anchor"></a></h2>

<p>There are two interfaces in the library: <code>Range&lt;T&gt;</code> and <code>Progression&lt;N&gt;</code>.</p>

<p><code>Range&lt;T&gt;</code> denotes an interval in the mathematical sense, defined for comparable types.
It has two endpoints: <code>start</code> and <code>end</code>, which are included in the range.
The main operation is <code>contains</code>, usually used in the form of <em class="keyword">in</em>/<em class="keyword">!in</em> operators.</p>

<p><code>Progression&lt;N&gt;</code> denotes an arithmetic progression, defined for number types.
It has <code>start</code>, <code>end</code> and a non-zero <code>increment</code>.
<code>Progression&lt;N&gt;</code> is a subtype of <code>Iterable&lt;N&gt;</code>, so it can be used in <em class="keyword">for</em>-loops and functions like <code>map</code>, <code>filter</code>, etc.
First element is <code>start</code>, every next element equals previous plus <code>increment</code>.
Iteration over <code>Progression</code> is equivalent to an indexed <em class="keyword">for</em>-loop in Java/JavaScript:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// if increment &gt; 0</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">increment</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span></code></pre>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// if increment &lt; 0</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">increment</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span></code></pre>

<p>For numbers, the <code>..</code> operator creates an object which is both <code>Range</code> and <code>Progression</code>.
Result of <code>downTo()</code> and <code>step()</code> functions is always a <code>Progression</code>.</p>

<h2 id="range-specifications">Range Specifications<a href="#range-specifications" class="anchor"></a></h2>

<h3 id="use-cases">Use Cases<a href="#use-cases" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// Checking if value of comparable is in range. Optimized for number primitives.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">10</span><span class="p">)</span> <span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

<span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="m">1.0</span><span class="p">..</span><span class="m">3.0</span><span class="p">)</span> <span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="k">in</span> <span class="s">&quot;island&quot;</span><span class="p">..</span><span class="s">&quot;isle&quot;</span><span class="p">)</span> <span class="n">println</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>

<span class="c1">// Iterating over arithmetical progression of numbers. Optimized for number primitives (as indexed for-loop in Java).</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">4</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;1234&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">4.</span><span class="p">.</span><span class="m">1</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints nothing</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">4</span> <span class="n">downTo</span> <span class="m">1</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;4321&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">4</span> <span class="n">step</span> <span class="m">2</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;13&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="m">1.</span><span class="p">.</span><span class="m">4</span><span class="p">).</span><span class="n">reversed</span><span class="p">())</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;4321&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="m">1.</span><span class="p">.</span><span class="m">4</span><span class="p">).</span><span class="n">reversed</span><span class="p">()</span> <span class="n">step</span> <span class="m">2</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;42&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">4</span> <span class="n">downTo</span> <span class="m">1</span> <span class="n">step</span> <span class="m">2</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// prints &quot;42&quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="m">1.0</span><span class="p">..</span><span class="m">2.0</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;$x &quot;</span><span class="p">)</span> <span class="c1">// prints &quot;1.0 2.0 &quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="m">1.0</span><span class="p">..</span><span class="m">2.0</span> <span class="n">step</span> <span class="m">0.3</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;$x &quot;</span><span class="p">)</span> <span class="c1">// prints &quot;1.0 1.3 1.6 1.9 &quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="m">2.0</span> <span class="n">downTo</span> <span class="m">1.0</span> <span class="n">step</span> <span class="m">0.3</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="s">&quot;$x &quot;</span><span class="p">)</span> <span class="c1">// prints &quot;2.0 1.7 1.4 1.1 &quot;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">str</span> <span class="k">in</span> <span class="s">&quot;island&quot;</span><span class="p">..</span><span class="s">&quot;isle&quot;</span><span class="p">)</span> <span class="n">println</span><span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="c1">// error: string range cannot be iterated over</span></code></pre>

<h3 id="common-interfaces-definition">Common Interfaces Definition<a href="#common-interfaces-definition" class="anchor"></a></h3>

<p>There are two base interfaces: <code>Range</code> and <code>Progression</code>.</p>

<p><code>Range</code> interface defines a range, or an interval in a mathematical sense.
It has two endpoints, <code>start</code> and <code>end</code>, and also <code>contains()</code> function which checks if the range contains a given number
(it also can be used as <em class="keyword">in</em>/<em class="keyword">!in</em> operator, which is neater).
<code>start</code> and <code>end</code> are included in the range. If <code>start</code> == <code>end</code>, the range contains exactly one element.
If <code>start</code> &gt; <code>end</code>, the range is empty.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">interface</span> <span class="n">Range</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">start</span><span class="p">:</span> <span class="n">T</span>
  <span class="k">val</span> <span class="py">end</span><span class="p">:</span> <span class="n">T</span>
  <span class="k">fun</span> <span class="nf">contains</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Boolean</span>
<span class="p">}</span></code></pre>

<p><code>Progression</code> defines a kind of arithmetical progression.
It has <code>start</code> (the first element of progression), <code>end</code> (the last element which can be included)
and <code>increment</code> (difference between each progression element and previous, non-zero).
But the main feature of it is that the progression can be iterated over, so it is a subtype of <code>Iterable</code>.
<code>end</code> is not necessary the last element of progression.
Also, progression can be empty if <code>start &lt; end &amp;&amp; increment &lt; 0</code> or <code>start &gt; end &amp;&amp; increment &gt; 0</code>.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">interface</span> <span class="n">Progression</span><span class="p">&lt;</span><span class="n">N</span> <span class="p">:</span> <span class="n">Number</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">Iterable</span><span class="p">&lt;</span><span class="n">N</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">start</span><span class="p">:</span> <span class="n">N</span>
  <span class="k">val</span> <span class="py">end</span><span class="p">:</span> <span class="n">N</span>
  <span class="k">val</span> <span class="py">increment</span><span class="p">:</span> <span class="n">Number</span> <span class="c1">// not N, because for Char we&#39;ll want it to be negative sometimes</span>
  <span class="c1">// fun iterator(): Iterator&lt;N&gt; is defined in Iterable interface</span>
<span class="p">}</span></code></pre>

<p>Iteration over <code>Progression</code> is equivalent to an indexed <em class="keyword">for</em>-loop in Java:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// if increment &gt; 0</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">increment</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span>

<span class="c1">// if increment &lt; 0</span>
<span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">increment</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span></code></pre>

<h3 id="implementation-classes">Implementation Classes<a href="#implementation-classes" class="anchor"></a></h3>

<p>To avoid unnecessary repetition, let’s consider only one number type, <code>Int</code>.
For other number types implementation is the same.
Note that instances can be created using constructors of these classes,
while it’s more handy to use <code>rangeTo()</code> (by this name, or as <code>..</code> operator), <code>downTo()</code>, <code>reversed()</code> and <code>step()</code> utility functions, which are introduced later.</p>

<p><code>IntProgression</code> class is pretty straightforward and simple:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">IntProgression</span><span class="p">(</span><span class="k">override</span> <span class="k">val</span> <span class="py">start</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">override</span> <span class="k">val</span> <span class="py">end</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">override</span> <span class="k">val</span> <span class="py">increment</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Progression</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">iterator</span><span class="p">():</span> <span class="n">Iterator</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">IntProgressionIteratorImpl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">increment</span><span class="p">)</span> <span class="c1">// implementation of iterator is obvious</span>
<span class="p">}</span></code></pre>

<p><code>IntRange</code> is a bit tricky: it implements <code>Progression&lt;Int&gt;</code> along with <code>Range&lt;Int&gt;</code>,
because it’s natural to iterate over a range (default increment value is 1 for both integer and floating-point types):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">IntRange</span><span class="p">(</span><span class="k">override</span> <span class="k">val</span> <span class="py">start</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="k">override</span> <span class="k">val</span> <span class="py">end</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Range</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;,</span> <span class="n">Progression</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">val</span> <span class="py">increment</span><span class="p">:</span> <span class="n">Int</span>
    <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="m">1</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">contains</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="n">start</span> <span class="p">&lt;=</span> <span class="n">element</span> <span class="p">&amp;&amp;</span> <span class="n">element</span> <span class="p">&lt;=</span> <span class="n">end</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">iterator</span><span class="p">():</span> <span class="n">Iterator</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">IntProgressionIteratorImpl</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">increment</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<p><code>ComparableRange</code> is also simple (remember that comparisons are translated into invocation of <code>compareTo()</code>):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">ComparableRange</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;(</span><span class="k">override</span> <span class="k">val</span> <span class="py">start</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="k">override</span> <span class="k">val</span> <span class="py">end</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Range</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
  <span class="k">override</span> <span class="k">fun</span> <span class="nf">contains</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="n">start</span> <span class="p">&lt;=</span> <span class="n">element</span> <span class="p">&amp;&amp;</span> <span class="n">element</span> <span class="p">&lt;=</span> <span class="n">end</span>
<span class="p">}</span></code></pre>

<h2 id="utility-functions">Utility functions<a href="#utility-functions" class="anchor"></a></h2>

<h3 id="rangeto"><code>rangeTo()</code><a href="#rangeto" class="anchor"></a></h3>

<p>Set of <code>rangeTo()</code> functions in number types simply call constructors of <code>*Range</code> classes, e.g.:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Int</span> <span class="p">{</span>
  <span class="c1">//...</span>
  <span class="k">fun</span> <span class="nf">rangeTo</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">Byte</span><span class="p">):</span> <span class="n">IntRange</span> <span class="p">=</span> <span class="n">IntRange</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="c1">//...</span>
  <span class="k">fun</span> <span class="nf">rangeTo</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">IntRange</span> <span class="p">=</span> <span class="n">IntRange</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
  <span class="c1">//...</span>
<span class="p">}</span></code></pre>

<h3 id="downto"><code>downTo()</code><a href="#downto" class="anchor"></a></h3>

<p><code>downTo()</code> extension function is defined for any pair of number types, here are two examples:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">Long</span><span class="p">.</span><span class="n">downTo</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">Double</span><span class="p">):</span> <span class="n">DoubleProgression</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">DoubleProgression</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="p">-</span><span class="m">1.0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">Byte</span><span class="p">.</span><span class="n">downTo</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">IntProgression</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">IntProgression</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<h3 id="reversed"><code>reversed()</code><a href="#reversed" class="anchor"></a></h3>

<p>Set of <code>reversed()</code> extension functions are defined for each <code>*Range</code> and <code>*Progression</code> classes, and all of them return reversed progressions.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">IntProgression</span><span class="p">.</span><span class="n">reversed</span><span class="p">():</span> <span class="n">IntProgression</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">IntProgression</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="p">-</span><span class="n">increment</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">IntRange</span><span class="p">.</span><span class="n">reversed</span><span class="p">():</span> <span class="n">IntProgression</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">IntProgression</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<h3 id="step"><code>step()</code><a href="#step" class="anchor"></a></h3>

<p><code>step()</code> extension functions are defined for each <code>*Range</code> and <code>*Progression</code> classes,
all of them return progressions with modified <code>step</code> value (function parameter).
Note that the step value is always positive, therefore this function never changes the direction of iteration.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">IntProgression</span><span class="p">.</span><span class="n">step</span><span class="p">(</span><span class="n">step</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">IntProgression</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span> <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;Step must be positive, was: $step&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">IntProgression</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="k">if</span> <span class="p">(</span><span class="n">increment</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="n">step</span> <span class="k">else</span> <span class="p">-</span><span class="n">step</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">IntRange</span><span class="p">.</span><span class="n">step</span><span class="p">(</span><span class="n">step</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">IntProgression</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="p">&lt;=</span> <span class="m">0</span><span class="p">)</span> <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;Step must be positive, was: $step&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">IntProgression</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
<span class="p">}</span></code></pre>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/typecasts.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="type-checks-and-casts">Type Checks and Casts<a href="#type-checks-and-casts" class="anchor"></a></h1>

<h2 id="is-and-is-operators"><code>is</code> and <code>!is</code> Operators<a href="#is-and-is-operators" class="anchor"></a></h2>

<p>We can check whether an object conforms to a given type at runtime by using the <code>is</code> operator or its negated form <code>!is</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="p">!</span><span class="k">is</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// same as !(obj is String)</span>
  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Not a String&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
  <span class="n">print</span><span class="p">(</span><span class="n">obj</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
<span class="p">}</span></code></pre>

<h2 id="smart-casts">Smart Casts<a href="#smart-casts" class="anchor"></a></h2>

<p>In many cases, one does not need to use explicit cast operators in Kotlin, because the compiler tracks the
<code>is</code>-checks for immutable values and inserts (safe) casts automatically when needed:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">demo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="k">is</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="c1">// x is automatically cast to String</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>The compiler is smart enough to know a cast to be safe if a negative check leads to a return:</p>

<pre><code class="code-block _highlighted lang_kotlin">  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">!</span><span class="k">is</span> <span class="n">String</span><span class="p">)</span> <span class="k">return</span>
  <span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="c1">// x is automatically cast to String</span></code></pre>

<p>or in the right-hand side of <code>&amp;&amp;</code> and <code>||</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin">  <span class="c1">// x is automatically cast to string on the right-hand side of `||`</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">!</span><span class="k">is</span> <span class="n">String</span> <span class="p">||</span> <span class="n">x</span><span class="p">.</span><span class="n">length</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="k">return</span>

  <span class="c1">// x is automatically cast to string on the right-hand side of `&amp;&amp;`</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="k">is</span> <span class="n">String</span> <span class="p">&amp;&amp;</span> <span class="n">x</span><span class="p">.</span><span class="n">length</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
      <span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">length</span><span class="p">)</span> <span class="c1">// x is automatically cast to String</span></code></pre>

<p>Such <em>smart casts</em> work for <a href="control-flow.html#when-expressions"><em class="keyword">when</em>-expressions</a>
and <a href="control-flow.html#while-loops"><em class="keyword">while</em>-loops</a> as well:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">when</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">is</span> <span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span>
  <span class="k">is</span> <span class="n">String</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">length</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span>
  <span class="k">is</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">-&gt;</span> <span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">sum</span><span class="p">())</span>
<span class="p">}</span></code></pre>

<h2 id="unsafe-cast-operator">“Unsafe” cast operator<a href="#unsafe-cast-operator" class="anchor"></a></h2>

<p>Usually, the cast operator throws an exception if the cast is not possible. Thus, we call it <em>unsafe</em>.
The unsafe cast in Kotlin is done by the infix operator <em class="keyword">as</em> (see <a href="grammar.html#operator-precedence">operator precedence</a>):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">x</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="n">y</span> <span class="k">as</span> <span class="n">String</span></code></pre>

<p>Note that <em class="keyword">null</em> cannot be cast to <code>String</code> as this type is not <a href="null-safety.html">nullable</a>,
i.e. if <code>y</code> is null, the code above throws an exception.
In order to match Java cast semantics we have to have nullable type at cast right hand side, like</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">x</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="n">y</span> <span class="k">as</span> <span class="n">String</span><span class="p">?</span></code></pre>

<h2 id="safe-nullable-cast-operator">“Safe” (nullable) cast operator<a href="#safe-nullable-cast-operator" class="anchor"></a></h2>

<p>To avoid an exception being thrown, one can use a <em>safe</em> cast operator <em class="keyword">as?</em> that returns <em class="keyword">null</em> on failure:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">x</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="n">y</span> <span class="k">as</span><span class="p">?</span> <span class="n">String</span></code></pre>

<p>Note that despite the fact that the right-hand side of <em class="keyword">as?</em> is a non-null type <code>String</code> the result of the cast is nullable.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/this-expressions.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="this-expression">This Expression<a href="#this-expression" class="anchor"></a></h1>

<p>To denote the current <em>receiver</em>, we use <em class="keyword">this</em> expressions:</p>

<ul>
  <li>In a member of a <a href="classes.html#inheritance">class</a>, <em class="keyword">this</em> refers to the current object of that class</li>
  <li>In an <a href="extensions.html">extension function</a> or an <a href="lambdas.html#function-literals">extension function literal</a>,
<em class="keyword">this</em> denotes the <em>receiver</em> parameter that is passed on the left-hand side of a dot.</li>
</ul>

<p>If <em class="keyword">this</em> has no qualifiers, it refers to the <em>innermost enclosing scope</em>. To refer to <em class="keyword">this</em> in other scopes, <em>label qualifiers</em> are used:</p>

<h2 id="qualified">Qualified <em class="keyword">this</em><a href="#qualified" class="anchor"></a></h2>

<p>To access <em class="keyword">this</em> from an outer scope (a <a href="classes.html">class</a>, or <a href="extensions.html">extension function</a>,
or labeled <a href="lambdas.html#function-literals">extension function literal</a> we write <code>this@label</code> where <code>@label</code> is a <a href="returns.html">label</a>
on the scope <em class="keyword">this</em> is meant to be from:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span> <span class="c1">// implicit label @A</span>
  <span class="k">inner</span> <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span> <span class="c1">// implicit label @B</span>
    <span class="k">fun</span> <span class="nf">Int</span><span class="p">.</span><span class="n">foo</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// implicit label @foo</span>
      <span class="k">val</span> <span class="py">a</span> <span class="p">=</span> <span class="k">this</span><span class="n">@A</span> <span class="c1">// A&#39;s this</span>
      <span class="k">val</span> <span class="py">b</span> <span class="p">=</span> <span class="k">this</span><span class="n">@B</span> <span class="c1">// B&#39;s this</span>

      <span class="k">val</span> <span class="py">c</span> <span class="p">=</span> <span class="k">this</span> <span class="c1">// foo()&#39;s receiver, an Int</span>
      <span class="k">val</span> <span class="py">c1</span> <span class="p">=</span> <span class="k">this</span><span class="n">@foo</span> <span class="c1">// foo()&#39;s receiver, an Int</span>

      <span class="k">val</span> <span class="py">funLit</span> <span class="p">=</span> <span class="n">@lambda</span> <span class="p">{</span><span class="n">String</span><span class="p">.()</span> <span class="p">-&gt;</span>
        <span class="k">val</span> <span class="py">d</span> <span class="p">=</span> <span class="k">this</span> <span class="c1">// funLit&#39;s receiver</span>
        <span class="k">val</span> <span class="py">d1</span> <span class="p">=</span> <span class="k">this</span><span class="n">@lambda</span> <span class="c1">// funLit&#39;s receiver</span>
      <span class="p">}</span>


      <span class="k">val</span> <span class="py">funLit2</span> <span class="p">=</span> <span class="p">{</span> <span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">-&gt;</span>
        <span class="c1">// foo()&#39;s receiver, since enclosing function literal </span>
        <span class="c1">// doesn&#39;t have any receiver</span>
        <span class="k">val</span> <span class="py">d1</span> <span class="p">=</span> <span class="k">this</span> 
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/equality.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="equality">Equality<a href="#equality" class="anchor"></a></h1>

<p>In Kotlin there are two types of equality:</p>

<ul>
  <li>Referential equality (two references point to the same object)</li>
  <li>Structural equality (a check for <code>equals()</code>)</li>
</ul>

<h2 id="referential-equality">Referential equality<a href="#referential-equality" class="anchor"></a></h2>

<p>Referential equality is checked by the <code>===</code> operation (and its negated counterpart <code>!==</code>). <code>a === b</code> evaluates to
true if and only if <code>a</code> and <code>b</code> point to the same object.</p>

<p>Alternatively, you can check for reference equality using a built-in inline function <code>identityEquals()</code>
that can be called in the following way</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">a</span><span class="p">.</span><span class="n">identityEquals</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="c1">// or</span>
<span class="n">a</span> <span class="n">identityEquals</span> <span class="n">b</span> <span class="c1">// infix call</span></code></pre>

<p>This also returns true if and only if <code>a</code> and <code>b</code> point to the same object.</p>

<h2 id="structural-equality">Structural equality<a href="#structural-equality" class="anchor"></a></h2>

<p>Structural equality is checked by the <code>==</code> operation (and its negated counterpart <code>!=</code>). By convention, an expression like <code>a == b</code> is translated to</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">a</span><span class="o">?.</span><span class="n">equals</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">?:</span> <span class="n">b</span> <span class="p">===</span> <span class="k">null</span></code></pre>

<p>I.e. if <code>a</code> is not <code>null</code>, it calls the <code>equals(Any?)</code> function, otherwise (i.e. <code>a</code> is <code>null</code>) it checks that <code>b</code> is referentially equal to <code>null</code>.</p>

<p>Note that there’s no point in optimizing your code when comparing to <code>null</code> explicitly: <code>a == null</code> will be automatically translated to <code>a === null</code>.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/operator-overloading.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="operator-overloading">Operator overloading<a href="#operator-overloading" class="anchor"></a></h1>

<p>Kotlin allows us to provide implementations for a predefined set of operators on our types. These operators have fixed symbolic representation
(like <code>+</code> or <code>*</code>) and fixed <a href="grammar.html#precedence">precedence</a>. To implement an operator, we provide a <a href="functions.html#member-functions">member function</a>
or an <a href="extensions.html">extension function</a> with a fixed name, for the corresponding type, i.e. left-hand side type for binary operations and argument type for unary ones.</p>

<h2 id="conventions">Conventions<a href="#conventions" class="anchor"></a></h2>

<p>Here we describe the conventions that regulate operator overloading for different operators.</p>

<h3 id="unary-operations">Unary operations<a href="#unary-operations" class="anchor"></a></h3>

<table>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>+a</code></td>
      <td><code>a.plus()</code></td>
    </tr>
    <tr>
      <td><code>-a</code></td>
      <td><code>a.minus()</code></td>
    </tr>
    <tr>
      <td><code>!a</code></td>
      <td><code>a.not()</code></td>
    </tr>
  </tbody>
</table>

<p>This table says that when the compiler processes, for example, an expression <code>+a</code>, it performs the following steps:</p>

<ul>
  <li>Determines the type of <code>a</code>, let it be <code>T</code>.</li>
  <li>Looks up a function <code>plus()</code> with no parameters for the receiver <code>T</code>, i.e. a member function or an extension function.</li>
  <li>If the function is absent or ambiguous, it is a compilation error.</li>
  <li>If the function is present and its return type is <code>R</code>, the expression <code>+a</code> has type <code>R</code>.</li>
</ul>

<p><em>Note</em> that these operations, as well as all the others, are optimized for <a href="basic-types.html">Basic types</a> and do not introduce overhead of function calls for them.</p>

<table>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a++</code></td>
      <td><code>a.inc()</code> + see below</td>
    </tr>
    <tr>
      <td><code>a--</code></td>
      <td><code>a.dec()</code> + see below</td>
    </tr>
  </tbody>
</table>

<p>These operations are supposed to change their receiver and (optionally) return a value.</p>

<blockquote class="note">
  <p><strong><code>inc()/dec()</code> shouldn’t mutate the receiver object</strong>.<br />
By “changing the receiver” we mean <em>the receiver-variable</em>, not the receiver object.</p>
</blockquote>

<p>The compiler performs the following steps for resolution of an operator in the <em>postfix</em> form, e.g. <code>a++</code>:</p>

<ul>
  <li>Determines the type of <code>a</code>, let it be <code>T</code>.</li>
  <li>Looks up a function <code>inc()</code> with no parameters, applicable to the receiver of type <code>T</code>.</li>
  <li>If the function returns a type <code>R</code>, then it must be a subtype of <code>T</code>.</li>
</ul>

<p>The effect of computing the expression is:</p>

<ul>
  <li>Store the initial value of <code>a</code> to a temporary storage <code>a0</code>,</li>
  <li>Assign the result of <code>a.inc()</code> to <code>a</code>,</li>
  <li>Return <code>a0</code> as a result of the expression.</li>
</ul>

<p>For <code>a--</code> the steps are completely analogous.</p>

<p>For the <em>prefix</em> forms <code>++a</code> and <code>--a</code> resolution works the same way, and the effect is:</p>

<ul>
  <li>Assign the result of <code>a.inc()</code> to <code>a</code>,</li>
  <li>Return the new value of <code>a</code> as a result of the expression.</li>
</ul>

<h3 id="binary-operations">Binary operations<a href="#binary-operations" class="anchor"></a></h3>

<table>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a + b</code></td>
      <td><code>a.plus(b)</code></td>
    </tr>
    <tr>
      <td><code>a - b</code></td>
      <td><code>a.minus(b)</code></td>
    </tr>
    <tr>
      <td><code>a * b</code></td>
      <td><code>a.times(b)</code></td>
    </tr>
    <tr>
      <td><code>a / b</code></td>
      <td><code>a.div(b)</code></td>
    </tr>
    <tr>
      <td><code>a % b</code></td>
      <td><code>a.mod(b)</code></td>
    </tr>
    <tr>
      <td><code>a..b </code></td>
      <td><code>a.rangeTo(b)</code></td>
    </tr>
  </tbody>
</table>

<p>For the operations in this table, the compiler just resolves the expression in the <em>Translated to</em> column.</p>

<table>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a in b</code></td>
      <td><code>b.contains(a)</code></td>
    </tr>
    <tr>
      <td><code>a !in b</code></td>
      <td><code>!b.contains(a)</code></td>
    </tr>
  </tbody>
</table>

<p id="in">For <code>in</code> and <code>!in</code> the procedure is the same, but the order of arguments is reversed.</p>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a[i]</code></td>
      <td><code>a.get(i)</code></td>
    </tr>
    <tr>
      <td><code>a[i, j]</code></td>
      <td><code>a.get(i, j)</code></td>
    </tr>
    <tr>
      <td><code>a[i_1, ...,  i_n]</code></td>
      <td><code>a.get(i_1, ...,  i_n)</code></td>
    </tr>
    <tr>
      <td><code>a[i] = b</code></td>
      <td><code>a.set(i, b)</code></td>
    </tr>
    <tr>
      <td><code>a[i, j] = b</code></td>
      <td><code>a.set(i, j, b)</code></td>
    </tr>
    <tr>
      <td><code>a[i_1, ...,  i_n] = b</code></td>
      <td><code>a.set(i_1, ..., i_n, b)</code></td>
    </tr>
  </tbody>
</table>

<p>Square brackets are translated to calls to <code>get</code> and <code>set</code> with appropriate numbers of arguments.</p>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a(i)</code></td>
      <td><code>a.invoke(i)</code></td>
    </tr>
    <tr>
      <td><code>a(i, j)</code></td>
      <td><code>a.invoke(i, j)</code></td>
    </tr>
    <tr>
      <td><code>a(i_1, ...,  i_n)</code></td>
      <td><code>a.invoke(i_1, ...,  i_n)</code></td>
    </tr>
  </tbody>
</table>

<p>Parentheses are translated to calls to invoke with appropriate number of arguments.</p>

<table id="assignments">
  <thead>
    <tr>
      <th>Expression</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a += b</code></td>
      <td><code>a.plusAssign(b)</code></td>
    </tr>
    <tr>
      <td><code>a -= b</code></td>
      <td><code>a.minusAssign(b)</code></td>
    </tr>
    <tr>
      <td><code>a *= b</code></td>
      <td><code>a.timesAssign(b)</code></td>
    </tr>
    <tr>
      <td><code>a /= b</code></td>
      <td><code>a.divAssign(b)</code></td>
    </tr>
    <tr>
      <td><code>a %= b</code></td>
      <td><code>a.modAssign(b)</code></td>
    </tr>
  </tbody>
</table>

<p>For the assignment operations, e.g. <code>a += b</code>, the compiler performs the following steps:</p>

<ul>
  <li>If the function from the right column is available
    <ul>
      <li>If the corresponding binary function (i.e. <code>plus()</code> for <code>plusAssign()</code>) is available too, report error (ambiguity).</li>
      <li>Make sure its return type is <code>Unit</code>, and report an error otherwise.</li>
      <li>Generate code for <code>a.plusAssign(b)</code></li>
    </ul>
  </li>
  <li>Otherwise, try to generate code for <code>a = a + b</code> (this includes a type check: the type of <code>a + b</code> must be a subtype of <code>a</code>).</li>
</ul>

<p id="Equals"><em>Note</em>: assignments are <em>NOT</em> expressions in Kotlin.</p>

<table>
  <thead>
    <tr>
      <th>Expression</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a == b</code></td>
      <td><code>a?.equals(b) ?: b.identityEquals(null)</code></td>
    </tr>
    <tr>
      <td><code>a != b</code></td>
      <td><code>!(a?.equals(b) ?: b.identityEquals(null))</code></td>
    </tr>
  </tbody>
</table>

<p><em>Note</em>: <code>===</code> and <code>!==</code> (identity checks) are not overloadable, so no conventions exist for them</p>

<p>The <code>==</code> operation is special in two ways:</p>

<ul>
  <li>It is translated to a complex expression that screens for <code>null</code>’s, and <code>null == null</code> is <code>true</code>.</li>
  <li>It looks up a function with a specific <em>signature</em>, not just a specific <em>name</em>. The function must be declared as</li>
</ul>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">equals</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">?):</span> <span class="n">Boolean</span></code></pre>

<p>Or an extension function with the same parameter list and return type.</p>

<table>
  <thead>
    <tr>
      <th>Symbol</th>
      <th>Translated to</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>a &gt; b</code></td>
      <td><code>a.compareTo(b) &gt; 0</code></td>
    </tr>
    <tr>
      <td><code>a &lt; b</code></td>
      <td><code>a.compareTo(b) &lt; 0</code></td>
    </tr>
    <tr>
      <td><code>a &gt;= b</code></td>
      <td><code>a.compareTo(b) &gt;= 0</code></td>
    </tr>
    <tr>
      <td><code>a &lt;= b</code></td>
      <td><code>a.compareTo(b) &lt;= 0</code></td>
    </tr>
  </tbody>
</table>

<p>All comparisons are translated into calls to <code>compareTo</code>, that is required to return <code>Int</code>.</p>

<h2 id="infix-calls-for-named-functions">Infix calls for named functions<a href="#infix-calls-for-named-functions" class="anchor"></a></h2>

<p>We can simulate custom infix operations by using <a href="functions.html#infix-notation">infix function calls</a>.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/null-safety.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="null-safety">Null Safety<a href="#null-safety" class="anchor"></a></h1>

<h2 id="nullable-types-and-non-null-types">Nullable types and Non-Null Types<a href="#nullable-types-and-non-null-types" class="anchor"></a></h2>

<p>Kotlin’s type system is aimed at eliminating null references from code, also known as the <a href="http://en.wikipedia.org/wiki/Tony_Hoare#Apologies_and_retractions">The Billion Dollar Mistake</a></p>

<p>One of the most common pitfalls in many programming languages, including Java is that of accessing a member of a null references, resulting in null reference exceptions. In Java this
would be the equivalent of a <code>NullPointerException</code> or NPE for short.</p>

<p>Kotlin’s type system is aimed to eliminate <code>NullPointerException</code>’s from our code. The only possible causes of NPE’s may be</p>

<ul>
  <li>An explicit call to <code>throw NullPointerException()</code></li>
  <li>External Java code has caused it</li>
  <li>There’s some data inconsistency with regard to initialization (an uninitialized <em>this</em> available in a constructor is used somewhere)</li>
</ul>

<p>In Kotlin the type system distinguishes between references that can hold <em class="keyword">null</em> (nullable references) and those that can not (non-null references).
For example, a regular variable of type <code>String</code> can not hold <em class="keyword">null</em>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="py">a</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span>
<span class="n">a</span> <span class="p">=</span> <span class="k">null</span> <span class="c1">// compilation error</span></code></pre>

<p>To allow nulls, we can declare a variable as nullable string, written <code>String?</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="py">b</span><span class="p">:</span> <span class="n">String</span><span class="p">?</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span>
<span class="n">b</span> <span class="p">=</span> <span class="k">null</span> <span class="c1">// ok</span></code></pre>

<p>Now, if you call a method on <code>a</code>, it’s guaranteed not to cause an NPE, so you can safely say</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">a</span><span class="p">.</span><span class="n">length</span><span class="p">()</span></code></pre>

<p>But if you want to call the same method on <code>b</code>, that would not be safe, and the compiler reports an error:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="c1">// error: variable &#39;b&#39; can be null</span></code></pre>

<p>But we still need to call that method, right? There are a few ways of doing that.</p>

<h2 id="checking-for-null-keyword--in-conditions">Checking for <em class="keyword">null</em> in conditions<a href="#checking-for-null-keyword--in-conditions" class="anchor"></a></h2>

<p>First, you can explicitly check if <code>b</code> is <em class="keyword">null</em>, and handle the two options separately:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="k">else</span> <span class="p">-</span><span class="m">1</span></code></pre>

<p>The compiler tracks the information about the check you performed, and allows the call to <code>length()</code> inside the <em class="keyword">if</em>.
More complex conditions are supported as well:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
  <span class="n">print</span><span class="p">(</span><span class="s">&quot;String of length ${b.length()}&quot;</span><span class="p">)</span>
<span class="k">else</span>
  <span class="n">print</span><span class="p">(</span><span class="s">&quot;Empty string&quot;</span><span class="p">)</span></code></pre>

<p>Note that this only works where <code>b</code> is immutable (i.e. a local variable which is not modified between the check and the
usage or a member <em class="keyword">val</em>which has a backing field and is not overridable), because otherwise it might
happen that <code>b</code> changes to <em class="keyword">null</em> after the check.</p>

<h2 id="safe-calls">Safe Calls<a href="#safe-calls" class="anchor"></a></h2>

<p>Your second option is the safe call operator, written <code>?.</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">b</span><span class="o">?.</span><span class="n">length</span><span class="p">()</span></code></pre>
<p>This returns <code>b.length()</code> if <code>b</code> is not null, and <em class="keyword">null</em> otherwise. The type of this expression is <code>Int?</code>.</p>

<p>Safe calls are useful in chains. For example, if Bob, an Employee, may be assigned to a Department (or not),
that in turn may have another Employee as a department head, then to obtain the name of Bob’s department head, if any), we write the following:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">bob</span><span class="o">?.</span><span class="n">department</span><span class="o">?.</span><span class="n">head</span><span class="o">?.</span><span class="n">name</span></code></pre>

<p>Such a chain returns <em class="keyword">null</em> if any of the properties in it is null.</p>

<h2 id="elvis-operator">Elvis Operator<a href="#elvis-operator" class="anchor"></a></h2>

<p>When we have a nullable reference <code>r</code>, we can say “if <code>r</code> is not null, use it, otherwise use some non-null value <code>x</code>”:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">l</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="n">b</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="k">else</span> <span class="p">-</span><span class="m">1</span></code></pre>

<p>Along with the complete <em class="keyword">if</em>-expression, this can be expressed with the Elvis operator, written <code>?:</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">b</span><span class="o">?.</span><span class="n">length</span><span class="p">()</span> <span class="o">?:</span> <span class="p">-</span><span class="m">1</span></code></pre>

<p>If the expression to the left of <code>?:</code> is not null, the elvis operator returns it, otherwise it returns the expression to the right.
Note that the right-hand side expression is evaluated only if the left-hand side is null.</p>

<p>Note that, since <em class="keyword">throw</em> and <em class="keyword">return</em> are expressions in Kotlin, they can also be used on
the right hand side of the elvis operator. This can be very handy, for example, for checking function arguments:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">foo</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Node</span><span class="p">):</span> <span class="n">String</span><span class="p">?</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">parent</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span> <span class="o">?:</span> <span class="k">return</span> <span class="k">null</span>
  <span class="k">val</span> <span class="py">name</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="o">?:</span> <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&quot;name expected&quot;</span><span class="p">)</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<h2 id="the--operator">The <code>!!</code> Operator<a href="#the--operator" class="anchor"></a></h2>

<p>The third option is for NPE-lovers. We can write <code>b!!</code>, and this will return a non-null value of <code>b</code>
(e.g., a <code>String</code> in our example) or throw an NPE if <code>b</code> is null:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">b</span><span class="o">!!</span><span class="p">.</span><span class="n">length</span><span class="p">()</span></code></pre>

<p>Thus, if you want an NPE, you can have it, but you have to ask for it explicitly, and it does not appear out of the blue.</p>

<p>By the way, <code>!!</code> is added for conciseness, and formerly was emulated by an extension function from the standard library, defined as follows:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span> <span class="p">:</span> <span class="n">Any</span><span class="p">&gt;</span> <span class="n">T</span><span class="o">?.</span><span class="n">sure</span><span class="p">():</span> <span class="n">T</span> <span class="p">=</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
    <span class="k">throw</span> <span class="n">NullPointerException</span><span class="p">()</span>
  <span class="k">else</span>
    <span class="k">this</span></code></pre>

<h2 id="safe-casts">Safe Casts<a href="#safe-casts" class="anchor"></a></h2>

<p>Regular casts may result into a <code>ClassCastException</code> if the object is not of the target type.
Another option is to use safe casts that return <em class="keyword">null</em> if the attempt was not successful:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">aInt</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="n">a</span> <span class="k">as</span><span class="p">?</span> <span class="n">Int</span></code></pre>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/exceptions.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="exceptions">Exceptions<a href="#exceptions" class="anchor"></a></h1>

<h2 id="exception-classes">Exception Classes<a href="#exception-classes" class="anchor"></a></h2>

<p>All exception classes in Kotlin are descendants of the class <code>Exception</code>.
Every exception has a message, stack trace and an optional cause.</p>

<p>To throw an exception object, use the <em class="keyword">throw</em>-expression</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">throw</span> <span class="n">MyException</span><span class="p">(</span><span class="s">&quot;Hi There!&quot;</span><span class="p">)</span></code></pre>

<p>To catch an exception, use the <em class="keyword">try</em>-expression</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">try</span> <span class="p">{</span>
  <span class="c1">// some code</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">SomeException</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// handler</span>
<span class="p">}</span>
<span class="k">finally</span> <span class="p">{</span>
  <span class="c1">// optional finally block</span>
<span class="p">}</span></code></pre>

<p>There may be zero or more <em class="keyword">catch</em> blocks. <em class="keyword">finally</em> blocks may be omitted.
However at least one <em class="keyword">catch</em> or <em class="keyword">finally</em> block should be present.</p>

<h3 id="try-is-an-expression">Try is an expression<a href="#try-is-an-expression" class="anchor"></a></h3>

<p><em class="keyword">try</em> is an expression, i.e. it may have a return value.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">?</span> <span class="p">=</span> <span class="k">try</span> <span class="p">{</span> <span class="n">parseInt</span><span class="p">(</span><span class="n">input</span><span class="p">)</span> <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">NumberFormatException</span><span class="p">)</span> <span class="p">{</span> <span class="k">null</span> <span class="p">}</span></code></pre>

<p>The returned value of a <em class="keyword">try</em>-expression is either the last expression in the <em class="keyword">try</em> block or the
last expression in the <em class="keyword">catch</em> block (or blocks).
Contents of the <em class="keyword">finally</em> block do not affect the result of the expression.</p>

<h2 id="checked-exceptions">Checked Exceptions<a href="#checked-exceptions" class="anchor"></a></h2>

<p>Kotlin does not have checked exceptions. There are many reasons for this, but we will provide a simple example.</p>

<p>The following is an example interface of the JDK implemented by <code>StringBuilder</code> class</p>

<pre><code class="code-block _highlighted lang_java"><span class="n">Appendable</span> <span class="nf">append</span><span class="o">(</span><span class="n">CharSequence</span> <span class="n">csq</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">;</span></code></pre>

<p>What does this signature say? It says that every time I append a string to something (a <code>StringBuilder</code>, some kind of a log, a console, etc.)
I have to catch those <code>IOExceptions</code>. Why? Because it might be performing IO (<code>Writer</code> also implements <code>Appendable</code>)…
So it results into this kind of code all over the place:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">try</span> <span class="p">{</span>
  <span class="n">log</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Must be safe</span>
<span class="p">}</span></code></pre>

<p>And this is no good, see <a href="http://www.oracle.com/technetwork/java/effectivejava-136174.html">Effective Java</a>, Item 65: <em>Don’t ignore exceptions</em>.</p>

<p>Bruce Eckel says in <a href="http://www.mindview.net/Etc/Discussions/CheckedExceptions">Does Java need Checked Exceptions?</a>:</p>

<blockquote>
  <p>Examination of small programs leads to the conclusion that requiring exception specifications could both enhance developer productivity and enhance code quality, but experience with large software projects suggests a different result – decreased productivity and little or no increase in code quality.</p>
</blockquote>

<p>Other citations of this sort:</p>

<ul>
  <li><a href="http://radio-weblogs.com/0122027/stories/2003/04/01/JavasCheckedExceptionsWereAMistake.html">Java’s checked exceptions were a mistake</a> (Rod Waldhoff)</li>
  <li><a href="http://www.artima.com/intv/handcuffs.html">The Trouble with Checked Exceptions</a> (Anders Hejlsberg)</li>
</ul>

<h2 id="java-interoperability">Java Interoperability<a href="#java-interoperability" class="anchor"></a></h2>

<p>Please see the section on exceptions in the <a href="java-interop.html">Java Interoperability section</a> for information about Java interoperability.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/annotations.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="annotations">Annotations<a href="#annotations" class="anchor"></a></h1>

<h2 id="annotation-declaration">Annotation Declaration<a href="#annotation-declaration" class="anchor"></a></h2>
<p>Annotations are means of attaching metadata to code. To declare an annotation, put the <em class="keyword">annotation</em> keyword in front of a class:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">annotation</span> <span class="k">class</span> <span class="nc">fancy</span></code></pre>

<h3 id="usage">Usage<a href="#usage" class="anchor"></a></h3>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">@fancy</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="n">@fancy</span> <span class="k">fun</span> <span class="nf">baz</span><span class="p">(</span><span class="n">@fancy</span> <span class="n">foo</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">@fancy</span> <span class="m">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>In most cases, the <code>@ </code>sign is optional. It is only required when annotating expressions or local declarations:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">fancy</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="n">fancy</span> <span class="k">fun</span> <span class="nf">baz</span><span class="p">(</span><span class="n">fancy</span> <span class="n">foo</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
    <span class="n">@fancy</span> <span class="k">fun</span> <span class="nf">bar</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">@fancy</span> <span class="m">1</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>If you need to annotate the primary constructor of a class, you need to add the <em class="keyword">constructor</em> keyword
to the constructor declaration, and add the annotations before it:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Foo</span> <span class="n">@inject</span> <span class="n">constructor</span><span class="p">(</span><span class="n">dependency</span><span class="p">:</span> <span class="n">MyDependency</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>You can also annotate property accessors:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">var</span> <span class="py">x</span><span class="p">:</span> <span class="n">MyDependency</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
        <span class="n">@inject</span> <span class="k">set</span>
<span class="p">}</span></code></pre>

<h3 id="constructors">Constructors<a href="#constructors" class="anchor"></a></h3>

<p>Annotations may have constructors that take parameters.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">annotation</span> <span class="k">class</span> <span class="nc">special</span><span class="p">(</span><span class="k">val</span> <span class="py">why</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>

<span class="n">special</span><span class="p">(</span><span class="s">&quot;example&quot;</span><span class="p">)</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{}</span></code></pre>

<h3 id="lambdas">Lambdas<a href="#lambdas" class="anchor"></a></h3>

<p>Annotations can also be used on lambdas. They will be applied to the <code>invoke()</code> method into which the body
of the lambda is generated. This is useful for frameworks like <a href="http://www.paralleluniverse.co/quasar/">Quasar</a>,
which uses annotations for concurrency control.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">annotation</span> <span class="k">class</span> <span class="nc">Suspendable</span>

<span class="k">val</span> <span class="py">f</span> <span class="p">=</span> <span class="n">@Suspendable</span> <span class="p">{</span> <span class="n">Fiber</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="p">}</span></code></pre>

<h2 id="java-annotations">Java Annotations<a href="#java-annotations" class="anchor"></a></h2>

<p>Java annotations are 100% compatible with Kotlin:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">import</span> <span class="nn">org.junit.Test</span>
<span class="k">import</span> <span class="nn">org.junit.Assert.*</span>

<span class="k">class</span> <span class="nc">Tests</span> <span class="p">{</span>
  <span class="n">Test</span> <span class="k">fun</span> <span class="nf">simple</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">assertEquals</span><span class="p">(</span><span class="m">42</span><span class="p">,</span> <span class="n">getTheAnswer</span><span class="p">())</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Java annotations can also be made to look like modifiers by renaming them on import:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">import</span> <span class="nn">org.junit.Test</span> <span class="k">as</span> <span class="n">test</span>

<span class="k">class</span> <span class="nc">Tests</span> <span class="p">{</span>
  <span class="n">test</span> <span class="k">fun</span> <span class="nf">simple</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>Since the order of parameters for an annotation written in Java is not defined, you can’t use a regular function
call syntax for passing the arguments. Instead, you need to use the named argument syntax.</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Ann</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">intValue</span><span class="o">();</span>
    <span class="n">String</span> <span class="nf">stringValue</span><span class="o">();</span>
<span class="o">}</span></code></pre>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// Kotlin</span>
<span class="n">Ann</span><span class="p">(</span><span class="n">intValue</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">stringValue</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span><span class="p">)</span> <span class="k">class</span> <span class="nc">C</span></code></pre>

<p>Just like in Java, a special case is the <code>value</code> parameter; its value can be specified without an explicit name.</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">AnnWithValue</span> <span class="o">{</span>
    <span class="n">String</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span></code></pre>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// Kotlin</span>
<span class="n">AnnWithValue</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">)</span> <span class="k">class</span> <span class="nc">C</span></code></pre>

<p>If the <code>value</code> argument in Java has an array type, it becomes a <code>vararg</code> parameter in Kotlin:</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">AnnWithArrayValue</span> <span class="o">{</span>
    <span class="n">String</span><span class="o">[]</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span></code></pre>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// Kotlin</span>
<span class="n">AnnWithArrayValue</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="s">&quot;bar&quot;</span><span class="p">)</span> <span class="k">class</span> <span class="nc">C</span></code></pre>

<p>If you need to specify a class as an argument of an annotation, use a Kotlin class
(<a href="/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html">KClass</a>). The Kotlin compiler will
automatically convert it to a Java class, so that the Java code will be able to see the annotations and arguments
normally.</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">import</span> <span class="nn">kotlin.reflect.KClass</span>

<span class="k">annotation</span> <span class="k">class</span> <span class="nc">Ann</span><span class="p">(</span><span class="k">val</span> <span class="py">arg1</span><span class="p">:</span> <span class="n">KClass</span><span class="p">&lt;*&gt;,</span> <span class="k">val</span> <span class="py">arg2</span><span class="p">:</span> <span class="n">KClass</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">Any</span><span class="p">?&gt;)</span>

<span class="n">Ann</span><span class="p">(</span><span class="n">String</span><span class="o">::</span><span class="k">class</span><span class="p">,</span> <span class="n">Int</span><span class="o">::</span><span class="k">class</span><span class="p">)</span> <span class="k">class</span> <span class="nc">MyClass</span></code></pre>

<p>Values of an annotation instance are exposed as properties to Kotlin code.</p>

<pre><code class="code-block _highlighted lang_java"><span class="c1">// Java</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Ann</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="nf">value</span><span class="o">();</span>
<span class="o">}</span></code></pre>

<pre><code class="code-block _highlighted lang_kotlin"><span class="c1">// Kotlin</span>
<span class="k">fun</span> <span class="nf">foo</span><span class="p">(</span><span class="n">ann</span><span class="p">:</span> <span class="n">Ann</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">i</span> <span class="p">=</span> <span class="n">ann</span><span class="p">.</span><span class="n">value</span>
<span class="p">}</span></code></pre>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/reflection.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="reflection">Reflection<a href="#reflection" class="anchor"></a></h1>

<p>Reflection is a set of language and library features that allows for introspecting the structure of you own program at runtime.
Kotlin makes functions and properties first-class citizens in the language, and introspecting them (i.e. learning a name or 
a type of a property or function at runtime) is closely intertwined with simply using functional or reactive style.</p>

<blockquote class="note">
  <p>On the Java platform, the runtime component required for using the reflection features is distributed as a separate
JAR file (<code>kotlin-reflect.jar</code>). This is done to reduce the required size of the runtime library for applications
that do not use reflection features. If you do use reflection, please make sure that the .jar file is added to the
classpath of your project.</p>
</blockquote>

<h2 id="class-references">Class References<a href="#class-references" class="anchor"></a></h2>

<p>The most basic reflection feature is getting the runtime reference to a Kotlin class. To obtain the reference to a
statically known Kotlin class, you can use the <em>class literal</em> syntax:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">c</span> <span class="p">=</span> <span class="n">MyClass</span><span class="o">::</span><span class="k">class</span></code></pre>

<p>The reference is a value of type <a href="/api/latest/jvm/stdlib/kotlin.reflect/-k-class/index.html">KClass</a>. You can use <code>KClass.properties</code>
and <code>KClass.extensionProperties</code> to get the list of <a href="#property-references">property references</a> for all properties
defined in this class and its superclasses.</p>

<p>Note that a Kotlin class reference is not the same as a Java class reference. See the <a href="java-interop.html#object-methods">Java interop section</a>
for information on obtaining a Java class reference corresponding to a Kotlin class.</p>

<h2 id="function-references">Function References<a href="#function-references" class="anchor"></a></h2>

<p>When we have a named function declared like this:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">isOdd</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span> <span class="p">%</span> <span class="m">2</span> <span class="p">!=</span> <span class="m">0</span></code></pre>

<p>We can easily call it directly (<code>isOdd(5)</code>), but we can also pass it as a value, e.g. to another function. 
To do this, we use the <code>::</code> operator:  </p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">numbers</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
<span class="n">println</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">::</span><span class="n">isOdd</span><span class="p">))</span> <span class="c1">// prints [1, 3]</span></code></pre>

<p>Here <code>::isOdd</code> is a value of function type <code>(Int) -&gt; Boolean</code>.</p>

<p>Note that right now the <code>::</code> operator cannot be used for overloaded functions. In the future, we plan to
provide a syntax for specifying parameter types so that a specific overload of a function could be selected.</p>

<p>If we need to use a member of a class, or an extension function, it needs to be qualified, 
and the result will be of type “extension function”,
e.g. <code>String::toCharArray</code> gives us an extension function for type <code>String</code>: <code>String.() -&gt; CharArray</code>.</p>

<h3 id="example-function-composition">Example: Function Composition<a href="#example-function-composition" class="anchor"></a></h3>

<p>Consider the following function:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">compose</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">&gt;(</span><span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">C</span><span class="p">,</span> <span class="n">g</span><span class="p">:</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">B</span><span class="p">):</span> <span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">C</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">x</span> <span class="p">-&gt;</span> <span class="n">f</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))}</span>
<span class="p">}</span></code></pre>

<p>It returns a composition of two functions passed to it: <code>compose(f, g) = f(g(*))</code>. 
Now, you can apply it to callable references:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">length</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span>
 
<span class="k">val</span> <span class="py">oddLength</span> <span class="p">=</span> <span class="n">compose</span><span class="p">(</span><span class="o">::</span><span class="n">isOdd</span><span class="p">,</span> <span class="o">::</span><span class="n">length</span><span class="p">)</span>
<span class="k">val</span> <span class="py">strings</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;ab&quot;</span><span class="p">,</span> <span class="s">&quot;abc&quot;</span><span class="p">)</span>

<span class="n">println</span><span class="p">(</span><span class="n">strings</span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="n">oddLength</span><span class="p">))</span> <span class="c1">// Prints &quot;[a, abc]&quot;</span></code></pre>

<h2 id="property-references">Property References<a href="#property-references" class="anchor"></a></h2>

<p>To access properties as first-class objects in Kotlin, we can also use the <code>::</code> operator:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">var</span> <span class="py">x</span> <span class="p">=</span> <span class="m">1</span>
 
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="o">::</span><span class="n">x</span><span class="p">.</span><span class="k">get</span><span class="p">())</span> <span class="c1">// prints &quot;1&quot;</span>
    <span class="o">::</span><span class="n">x</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
    <span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>         <span class="c1">// prints &quot;2&quot;</span>
<span class="p">}</span></code></pre>

<p>The expression <code>::x</code> evaluates to a property object of type <code>KProperty&lt;Int&gt;</code>, which allows us to read its
value using <code>get()</code> or retrieve the property name using the <code>name</code> property. For more information, please refer to
the <a href="/api/latest/jvm/stdlib/kotlin.reflect/-k-property.html">docs on the <code>KProperty</code> class</a>.</p>

<p>For a mutable property, e.g. <code>var y = 1</code>, <code>::y</code> returns a value of type <a href="/api/latest/jvm/stdlib/kotlin.reflect/-k-mutable-property.html"><code>KMutableProperty&lt;Int&gt;</code></a>,
which has a <code>set()</code> method. </p>

<p>To access a property that is a member of a class, we qualify it:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="k">val</span> <span class="py">p</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
 
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">prop</span> <span class="p">=</span> <span class="n">A</span><span class="o">::</span><span class="n">p</span>
    <span class="n">println</span><span class="p">(</span><span class="n">prop</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="n">A</span><span class="p">(</span><span class="m">1</span><span class="p">)))</span> <span class="c1">// prints &quot;1&quot;</span>
<span class="p">}</span></code></pre>

<p>For an extension property:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">String</span><span class="p">.</span><span class="n">lastChar</span><span class="p">:</span> <span class="n">Char</span>
  <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="k">this</span><span class="p">[</span><span class="n">size</span> <span class="p">-</span> <span class="m">1</span><span class="p">]</span>
 
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
  <span class="n">println</span><span class="p">(</span><span class="n">String</span><span class="o">::</span><span class="n">lastChar</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="s">&quot;abc&quot;</span><span class="p">))</span> <span class="c1">// prints &quot;c&quot;</span>
<span class="p">}</span></code></pre>

<h3 id="interoperability-with-java-reflection">Interoperability With Java Reflection<a href="#interoperability-with-java-reflection" class="anchor"></a></h3>

<p>On the Java platform, standard library contains extensions for reflection classes that provide a mapping to and from Java
  reflection objects (see package <code>kotlin.reflect.jvm</code>).
For example, to find a backing field or a Java method that serves as a getter for a Kotlin property, you can say something like this:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">import</span> <span class="nn">kotlin.reflect.jvm.*</span>
 
<span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="k">val</span> <span class="py">p</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
 
<span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
    <span class="n">println</span><span class="p">(</span><span class="n">A</span><span class="o">::</span><span class="n">p</span><span class="p">.</span><span class="n">javaGetter</span><span class="p">)</span> <span class="c1">// prints &quot;public final int A.getP()&quot;</span>
    <span class="n">println</span><span class="p">(</span><span class="n">A</span><span class="o">::</span><span class="n">p</span><span class="p">.</span><span class="n">javaField</span><span class="p">)</span>  <span class="c1">// prints &quot;private final int A.p&quot;</span>
<span class="p">}</span></code></pre>

<h2 id="constructor-references">Constructor References<a href="#constructor-references" class="anchor"></a></h2>

<p>Constructors can be referenced just like methods and properties. They can be used wherever an object of function type 
is expected that takes the same parameters as the constructor and returns an object of the appropriate type. 
Constructors are referenced by using the <code>::</code> operator and adding the class name. Consider the following function 
that expects a function parameter with no parameters and return type <code>Foo</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">class</span> <span class="nc">Foo</span>

<span class="k">fun</span> <span class="nf">function</span><span class="p">(</span><span class="n">factory</span> <span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Foo</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">x</span> <span class="p">:</span> <span class="n">Foo</span> <span class="p">=</span> <span class="n">factory</span><span class="p">()</span>
<span class="p">}</span></code></pre>

<p>Using <code>::Foo</code>, the zero-argument constructor of the class Foo, we can simply call it like this:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">function</span><span class="p">(</span><span class="o">::</span><span class="n">Foo</span><span class="p">)</span></code></pre>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/type-safe-builders.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <p>The concept of <a href="http://groovy.codehaus.org/Builders">builders</a> is rather popular in the <em>Groovy</em> community. 
Builders allow for defining data in a semi-declarative way. Builders are good for <a href="http://groovy.codehaus.org/GroovyMarkup">generating XML</a>, 
<a href="http://groovy.codehaus.org/GroovySWT">laying out UI components</a>, 
<a href="http://www.artima.com/weblogs/viewpost.jsp?thread=296081">describing 3D scenes</a> and more…</p>

<p>For many use cases, Kotlin allows to <em>type-check</em> builders, which makes them even more attractive than the 
dynamically-typed implementation made in Groovy itself.</p>

<p>For the rest of the cases, Kotlin supports Dynamic types builders.</p>

<h2 id="a-type-safe-builder-example">A type-safe builder example<a href="#a-type-safe-builder-example" class="anchor"></a></h2>

<p>Consider the following code that is taken from <a href="http://groovy.codehaus.org/Builders">here</a> and slightly adapted:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">import</span> <span class="nn">com.example.html.*</span> <span class="c1">// see declarations below</span>

<span class="k">fun</span> <span class="nf">result</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">=</span>
  <span class="n">html</span> <span class="p">{</span>
    <span class="n">head</span> <span class="p">{</span>
      <span class="n">title</span> <span class="p">{+</span><span class="s">&quot;XML encoding with Kotlin&quot;</span><span class="p">}</span>
    <span class="p">}</span>
    <span class="n">body</span> <span class="p">{</span>
      <span class="n">h1</span> <span class="p">{+</span><span class="s">&quot;XML encoding with Kotlin&quot;</span><span class="p">}</span>
      <span class="n">p</span>  <span class="p">{+</span><span class="s">&quot;this format can be used as an alternative markup to XML&quot;</span><span class="p">}</span>

      <span class="c1">// an element with attributes and text content</span>
      <span class="n">a</span><span class="p">(</span><span class="n">href</span> <span class="p">=</span> <span class="s">&quot;http://kotlinlang.org&quot;</span><span class="p">)</span> <span class="p">{+</span><span class="s">&quot;Kotlin&quot;</span><span class="p">}</span>

      <span class="c1">// mixed content</span>
      <span class="n">p</span> <span class="p">{</span>
        <span class="p">+</span><span class="s">&quot;This is some&quot;</span>
        <span class="n">b</span> <span class="p">{+</span><span class="s">&quot;mixed&quot;</span><span class="p">}</span>
        <span class="p">+</span><span class="s">&quot;text. For more see the&quot;</span>
        <span class="n">a</span><span class="p">(</span><span class="n">href</span> <span class="p">=</span> <span class="s">&quot;http://kotlinlang.org&quot;</span><span class="p">)</span> <span class="p">{+</span><span class="s">&quot;Kotlin&quot;</span><span class="p">}</span>
        <span class="p">+</span><span class="s">&quot;project&quot;</span>
      <span class="p">}</span>
      <span class="n">p</span> <span class="p">{+</span><span class="s">&quot;some text&quot;</span><span class="p">}</span>

      <span class="c1">// content generated by</span>
      <span class="n">p</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">arg</span> <span class="k">in</span> <span class="n">args</span><span class="p">)</span>
          <span class="p">+</span><span class="n">arg</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span></code></pre>

<p>This is a completely legitimate Kotlin code. 
You can play with this code online (modify it and run in the browser) <a href="http://try.kotlinlang.org/#/Examples/Longer examples/HTML Builder/HTML Builder.kt">here</a>.</p>

<h2 id="how-it-works">How it works<a href="#how-it-works" class="anchor"></a></h2>

<p>Let’s walk through the mechanisms of implementing type-safe builders in Kotlin.
First of all we need to define the model we want to build, in this case we need to model HTML tags.
It is easily done with a bunch of classes.
For example, <code>HTML</code> is a class that describes the <code>&lt;html&gt;</code> tag, i.e. it defines children like <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code>.
(See its declaration <a href="#declarations">below</a>.)</p>

<p>Now, let’s recall why we can say something like this in the code:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">html</span> <span class="p">{</span>
 <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>This is actually a function call that takes a <a href="lambdas.html">function literal</a> as an argument
(see <a href="lambdas.html#higher-order-functions">this page</a> for details). Actually, this function is defined as follows:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">html</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">HTML</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">HTML</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">html</span> <span class="p">=</span> <span class="n">HTML</span><span class="p">()</span>
  <span class="n">html</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">html</span>
<span class="p">}</span></code></pre>

<p>This function takes one parameter named <code>init</code>, which is itself a function.
Actually, it is an <a href="extensions.html">extension function</a> that has a receiver of type <code>HTML</code> (and returns nothing interesting, i.e. <code>Unit</code>).
So, when we pass a function literal as an argument to <code>html</code>, it is typed as an extension function literal,
and there’s a <em class="keyword">this</em> reference available:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">html</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="n">head</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
  <span class="k">this</span><span class="p">.</span><span class="n">body</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>(<code>head</code> and <code>body</code> are member functions of <code>html</code>.)</p>

<p>Now, <em class="keyword">this</em> can be omitted, as usual, and we get something that looks very much like a builder already:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">html</span> <span class="p">{</span>
  <span class="n">head</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
  <span class="n">body</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
<span class="p">}</span></code></pre>

<p>So, what does this call do? Let’s look at the body of <code>html</code> function as defined above.
It creates a new instance of <code>HTML</code>, then it initializes it by calling the function that is passed as an argument
(in our example this boils down to calling <code>head</code> and <code>body</code> on the <code>HTML</code> instance), and then it returns this instance. 
This is exactly what a builder should do.</p>

<p>The <code>head</code> and <code>body</code> functions in the <code>HTML</code> class are defined similarly to <code>html</code>. 
The only difference is that they add the built instances to the <code>children</code> collection of the enclosing <code>HTML</code> instance:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">head</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">Head</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">head</span> <span class="p">=</span> <span class="n">Head</span><span class="p">()</span>
  <span class="n">head</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
  <span class="n">children</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">head</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">body</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">Body</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">val</span> <span class="py">body</span> <span class="p">=</span> <span class="n">Body</span><span class="p">()</span>
  <span class="n">body</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
  <span class="n">children</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">body</span>
<span class="p">}</span></code></pre>

<p>Actually these two functions do just the same thing, so we can have a generic version, <code>initTag</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin">  <span class="k">protected</span> <span class="k">fun</span> <span class="nf">initTag</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">Element</span><span class="p">&gt;(</span><span class="n">tag</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">init</span><span class="p">:</span> <span class="n">T</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">T</span> <span class="p">{</span>
    <span class="n">tag</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
    <span class="n">children</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tag</span>
  <span class="p">}</span></code></pre>

<p>So, now our functions are very simple:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">head</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">Head</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">initTag</span><span class="p">(</span><span class="n">Head</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>

<span class="k">fun</span> <span class="nf">body</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">Body</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">initTag</span><span class="p">(</span><span class="n">Body</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span></code></pre>

<p>And we can use them to build <code>&lt;head&gt;</code> and <code>&lt;body&gt;</code> tags. </p>

<p>One other thing to be discussed here is how we add text to tag bodies. In the example above we say something like</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">html</span> <span class="p">{</span>
  <span class="n">head</span> <span class="p">{</span>
    <span class="n">title</span> <span class="p">{+</span><span class="s">&quot;XML encoding with Kotlin&quot;</span><span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// ...</span>
<span class="p">}</span></code></pre>

<p>So basically, we just put a string inside a tag body, but there is this little <code>+</code> in front of it,
so it is a function call that invokes a prefix <code>plus()</code> operation. 
That operation is actually defined by an extension function <code>plus()</code> that is a member of the <code>TagWithText</code> abstract class (a parent of <code>Title</code>):</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">fun</span> <span class="nf">String</span><span class="p">.</span><span class="n">plus</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">children</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">TextElement</span><span class="p">(</span><span class="k">this</span><span class="p">))</span>
<span class="p">}</span></code></pre>

<p>So, what the prefix <code>+</code> does here is it wraps a string into an instance of <code>TextElement</code> and adds it to the <code>children</code> collection,
so that it becomes a proper part of the tag tree.</p>

<p>All this is defined in a package <code>com.example.html</code> that is imported at the top of the builder example above.
In the next section you can read through the full definition of this package.</p>

<h2 id="full-definition-of-the-comexamplehtml-package">Full definition of the <code>com.example.html</code> package<a href="#full-definition-of-the-comexamplehtml-package" class="anchor"></a></h2>

<p>This is how the package <code>com.example.html</code> is defined (only the elements used in the example above).
It builds an HTML tree. It makes heavy use of <a href="extensions.html">Extension functions</a> and
<a href="lambdas.html#extension-function-expressions">Extension function literals</a>.</p>

<p><a name="declarations"></a></p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">package</span> <span class="nn">com.example.html</span>

<span class="n">interface</span> <span class="n">Element</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">render</span><span class="p">(</span><span class="n">builder</span><span class="p">:</span> <span class="n">StringBuilder</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">toString</span><span class="p">():</span> <span class="n">String</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">builder</span> <span class="p">=</span> <span class="n">StringBuilder</span><span class="p">()</span>
        <span class="n">render</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">builder</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">TextElement</span><span class="p">(</span><span class="k">val</span> <span class="py">text</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Element</span> <span class="p">{</span>
    <span class="k">override</span> <span class="k">fun</span> <span class="nf">render</span><span class="p">(</span><span class="n">builder</span><span class="p">:</span> <span class="n">StringBuilder</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">builder</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;$indent$text\n&quot;</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tag</span><span class="p">(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Element</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">children</span> <span class="p">=</span> <span class="n">arrayListOf</span><span class="p">&lt;</span><span class="n">Element</span><span class="p">&gt;()</span>
    <span class="k">val</span> <span class="py">attributes</span> <span class="p">=</span> <span class="n">hashMapOf</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="p">&gt;()</span>

    <span class="k">protected</span> <span class="k">fun</span> <span class="nf">initTag</span><span class="p">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Element</span><span class="p">&gt;(</span><span class="n">tag</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">init</span><span class="p">:</span> <span class="n">T</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">T</span> <span class="p">{</span>
        <span class="n">tag</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
        <span class="n">children</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tag</span>
    <span class="p">}</span>

    <span class="k">override</span> <span class="k">fun</span> <span class="nf">render</span><span class="p">(</span><span class="n">builder</span><span class="p">:</span> <span class="n">StringBuilder</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">builder</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;$indent&lt;$name${renderAttributes()}&gt;\n&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="k">in</span> <span class="n">children</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">c</span><span class="p">.</span><span class="n">render</span><span class="p">(</span><span class="n">builder</span><span class="p">,</span> <span class="n">indent</span> <span class="p">+</span> <span class="s">&quot;  &quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">builder</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;$indent&lt;/$name&gt;\n&quot;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">fun</span> <span class="nf">renderAttributes</span><span class="p">():</span> <span class="n">String</span><span class="p">?</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">builder</span> <span class="p">=</span> <span class="n">StringBuilder</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a</span> <span class="k">in</span> <span class="n">attributes</span><span class="p">.</span><span class="n">keySet</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">builder</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; $a=\&quot;${attributes[a]}\&quot;&quot;</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">builder</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">TagWithText</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">Tag</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">String</span><span class="p">.</span><span class="n">plus</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">children</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">TextElement</span><span class="p">(</span><span class="k">this</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">HTML</span><span class="p">():</span> <span class="n">TagWithText</span><span class="p">(</span><span class="s">&quot;html&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">head</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">Head</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">initTag</span><span class="p">(</span><span class="n">Head</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>

    <span class="k">fun</span> <span class="nf">body</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">Body</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">initTag</span><span class="p">(</span><span class="n">Body</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Head</span><span class="p">():</span> <span class="n">TagWithText</span><span class="p">(</span><span class="s">&quot;head&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">title</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">Title</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">initTag</span><span class="p">(</span><span class="n">Title</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Title</span><span class="p">():</span> <span class="n">TagWithText</span><span class="p">(</span><span class="s">&quot;title&quot;</span><span class="p">)</span>

<span class="k">abstract</span> <span class="k">class</span> <span class="nc">BodyTag</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">):</span> <span class="n">TagWithText</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">fun</span> <span class="nf">b</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">B</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">initTag</span><span class="p">(</span><span class="n">B</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>
    <span class="k">fun</span> <span class="nf">p</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">P</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">initTag</span><span class="p">(</span><span class="n">P</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>
    <span class="k">fun</span> <span class="nf">h1</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">H1</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span> <span class="n">initTag</span><span class="p">(</span><span class="n">H1</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>
    <span class="k">fun</span> <span class="nf">a</span><span class="p">(</span><span class="n">href</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">init</span><span class="p">:</span> <span class="n">A</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">initTag</span><span class="p">(</span><span class="n">A</span><span class="p">(),</span> <span class="n">init</span><span class="p">)</span>
        <span class="n">a</span><span class="p">.</span><span class="n">href</span> <span class="p">=</span> <span class="n">href</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Body</span><span class="p">():</span> <span class="n">BodyTag</span><span class="p">(</span><span class="s">&quot;body&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">B</span><span class="p">():</span> <span class="n">BodyTag</span><span class="p">(</span><span class="s">&quot;b&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">P</span><span class="p">():</span> <span class="n">BodyTag</span><span class="p">(</span><span class="s">&quot;p&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">H1</span><span class="p">():</span> <span class="n">BodyTag</span><span class="p">(</span><span class="s">&quot;h1&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">():</span> <span class="n">BodyTag</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">var</span> <span class="py">href</span><span class="p">:</span> <span class="n">String</span>
        <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">attributes</span><span class="p">[</span><span class="s">&quot;href&quot;</span><span class="p">]</span><span class="o">!!</span>
        <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">attributes</span><span class="p">[</span><span class="s">&quot;href&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="n">value</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="k">fun</span> <span class="nf">html</span><span class="p">(</span><span class="n">init</span><span class="p">:</span> <span class="n">HTML</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">HTML</span> <span class="p">{</span>
    <span class="k">val</span> <span class="py">html</span> <span class="p">=</span> <span class="n">HTML</span><span class="p">()</span>
    <span class="n">html</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">html</span>
<span class="p">}</span></code></pre>

<h3 id="appendix-making-java-classes-nicer">Appendix. Making Java classes nicer<a href="#appendix-making-java-classes-nicer" class="anchor"></a></h3>

<p>In the code above there’s something that looks very nice:</p>

<pre><code class="code-block _highlighted lang_kotlin">  <span class="k">class</span> <span class="nc">A</span><span class="p">()</span> <span class="p">:</span> <span class="n">BodyTag</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="py">href</span><span class="p">:</span> <span class="n">String</span>
      <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">attributes</span><span class="p">[</span><span class="s">&quot;href&quot;</span><span class="p">]</span><span class="o">!!</span>
      <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">attributes</span><span class="p">[</span><span class="s">&quot;href&quot;</span><span class="p">]</span> <span class="p">=</span> <span class="n">value</span> <span class="p">}</span>
  <span class="p">}</span></code></pre>

<p>We access the <code>attributes</code> map as if it were an <em>associative array</em>: just with the <code>[]</code> operation.
By <a href="operator-overloading.html">convention</a> this compiles to a call to <code>get(K)</code> or <code>set(K, V)</code>, all right.
But we said that <code>attributes</code> was a <em>Java</em> <code>Map</code>, i.e. it does NOT have a <code>set(K, V)</code>. 
This problem is easily fixable in Kotlin:</p>

<pre><code class="code-block _highlighted lang_kotlin">  <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">K</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="p">&gt;.</span><span class="k">set</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="n">K</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">V</span><span class="p">)</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></code></pre>

<p>So, we simply define an <a href="extensions.html">extension function</a> <code>set(K, V)</code> that delegates to vanilla <code>put</code>
and makes a Kotlin operator available for a <em>Java</em> class.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/dynamic-type.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="dynamic-type">Dynamic Type<a href="#dynamic-type" class="anchor"></a></h1>

<p>Being a statically typed language, Kotlin still has to interoperate with untyped or loosely typed environments,
such as JavaScript ecosystem. To facilitate these use cases, the <code>dynamic</code> type is available in the language:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="k">val</span> <span class="py">dyn</span><span class="p">:</span> <span class="n">dynamic</span> <span class="p">=</span> <span class="p">...</span></code></pre>

<p>The <code>dynamic</code> type basically turns off Kotlin’s type checker:</p>

<ul>
  <li>a value of this type can be assigned to any variable or passed anywhere as a parameter,</li>
  <li>any value can be assigned to a variable of type <code>dynamic</code> or passed to a function that takes <code>dynamic</code> as a parameter,</li>
  <li><code>null</code>-checks are disabled for such values.</li>
</ul>

<p>The most peculiar feature of <code>dynamic</code> is that we are allowed to call <strong>any</strong> property or function with any parameters
on a <code>dynamic</code> variable:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">dyn</span><span class="p">.</span><span class="n">whatever</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="n">dyn</span><span class="p">)</span> <span class="c1">// &#39;whatever&#39; is not defined anywhere</span>
<span class="n">dyn</span><span class="p">.</span><span class="n">whatever</span><span class="p">(*</span><span class="n">array</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">))</span></code></pre>

<p>On the JavaScript platform this code will be compiled “as is”: <code>dyn.whatever(1)</code> in Kotlin becomes <code>dyn.whatever(1)</code> in
the generated JavaScript code.</p>

<p>A dynamic call always returns <code>dynamic</code> as a result, so we can chain such calls freely:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">dyn</span><span class="p">.</span><span class="n">foo</span><span class="p">().</span><span class="n">bar</span><span class="p">.</span><span class="n">baz</span><span class="p">()</span></code></pre>

<p>When we pass a lambda to a dynamic call, all of its parameters by default have the type <code>dynamic</code>:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="n">dyn</span><span class="p">.</span><span class="n">foo</span> <span class="p">{</span>
  <span class="n">x</span> <span class="p">-&gt;</span> <span class="n">x</span><span class="p">.</span><span class="n">bar</span><span class="p">()</span> <span class="c1">// x is dynamic</span>
<span class="p">}</span></code></pre>

<p>For a more technical description, see the <a href="https://github.com/JetBrains/kotlin/blob/master/spec-docs/dynamic-types.md">spec document</a>.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/kotlin-doc.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="documenting-kotlin-code">Documenting Kotlin Code<a href="#documenting-kotlin-code" class="anchor"></a></h1>

<p>The language used to document Kotlin code (the equivalent of Java’s JavaDoc) is called <strong>KDoc</strong>. In its essence, KDoc
combines JavaDoc’s syntax for block tags (extended to support Kotlin’s specific constructs) and Markdown for
inline markup.</p>

<p>Just like with JavaDoc, KDoc comments start with <code>/**</code> and end with <code>*/</code>. Every line of the comment may begin with
an asterisk, which is not considered part of the contents of the comment.</p>

<p>By convention, the first paragraph of the documentation text (the block of text until the first blank line) is the
summary description of the element, and the following text is the detailed description.</p>

<p>Every block tag begins on a new line and starts with the <code>@</code> character.</p>

<p>Here’s an example of a class documented using KDoc:</p>

<pre><code class="code-block _highlighted lang_kotlin"><span class="cm">/**</span>
<span class="cm"> * A group of *members*.</span>
<span class="cm"> *</span>
<span class="cm"> * This class has no useful logic; it&#39;s just a documentation example.</span>
<span class="cm"> *</span>
<span class="cm"> * @param T the type of a member in this group.</span>
<span class="cm"> * @property name the name of this group.</span>
<span class="cm"> * @constructor Creates an empty group.</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">Group</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**</span>
<span class="cm">     * Adds a [member] to this group.</span>
<span class="cm">     * @return the new size of the group.</span>
<span class="cm">     */</span>
    <span class="k">fun</span> <span class="nf">add</span><span class="p">(</span><span class="n">member</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
<span class="p">}</span></code></pre>

<h2 id="block-tags">Block Tags<a href="#block-tags" class="anchor"></a></h2>

<p>KDoc currently supports the following block tags:</p>

<h4 id="param-name"><code>@param &lt;name&gt;</code></h4>

<p>Documents a value parameter of a function or a type parameter of a class.
To better separate the parameter name from the description, if you prefer, you can enclose the name of the
parameter in brackets. The following two syntaxes are therefore equivalent:</p>

<pre>@param name description.
@param[name] description.
</pre>

<h4 id="return"><code>@return</code></h4>

<p>Documents the return value of a function.</p>

<h4 id="constructor"><code>@constructor</code></h4>

<p>Documents the primary constructor of a class.</p>

<h4 id="property-name"><code>@property &lt;name&gt;</code></h4>

<p>Documents the property of a class which has the specified name. This tag can be used for documenting properties
declared in the primary constructor, where putting a doc comment directly before the property definition would be
awkward.</p>

<h4 id="throws-class-exception-class"><code>@throws &lt;class&gt;</code>, <code>@exception &lt;class&gt;</code></h4>

<p>Documents an exception which can be thrown by a method. Since Kotlin does not have checked exceptions, there is
also no expectation that all possible exceptions are documented, but you can still use this tag when it provides
useful information for users of the class.</p>

<h4 id="sample-identifier"><code>@sample &lt;identifier&gt;</code></h4>

<p>Embeds the body of the function with the specified qualified name into the documentation for the current element,
in order to show an example of how the element could be used.</p>

<h4 id="see-identifier"><code>@see &lt;identifier&gt;</code></h4>

<p>Adds a link to the specified class or method to the <strong>See Also</strong> block of the documentation.</p>

<h4 id="author"><code>@author</code></h4>

<p>Specifies the author of the element being documented.</p>

<h4 id="since"><code>@since</code></h4>

<p>Specifies the version of the software in which the element being documented was introduced.</p>

<h4 id="suppress"><code>@suppress</code></h4>

<p>Excludes the element from the generated documentation. Can be used for elements which are not part of the official
API of a module but still have to be visible externally.</p>

<blockquote class="note">
  <p>KDoc does not support the <code>@deprecated</code> tag. Instead, please use the <code>@deprecated</code> annotation.</p>
</blockquote>

<h2 id="inline-markup">Inline Markup<a href="#inline-markup" class="anchor"></a></h2>

<p>For inline markup, KDoc uses the regular <a href="http://daringfireball.net/projects/markdown/syntax">Markdown</a> syntax, extended
to support a shorthand syntax for linking to other elements in the code.</p>

<h3 id="linking-to-elements">Linking to Elements<a href="#linking-to-elements" class="anchor"></a></h3>

<p>To link to another element (class, method, property or parameter), simply put its name in square brackets:</p>

<pre>Use the method [foo] for this purpose.
</pre>

<p>If you want to specify a custom label for the link, use the Markdown reference-style syntax:</p>

<pre>Use [this method][foo] for this purpose.
</pre>

<p>You can also use qualified names in the links. Note that, unlike JavaDoc, qualified names always use the dot character
to separate the components, even before a method name:</p>

<pre>Use [kotlin.reflect.KClass.properties] to enumerate the properties of the class.
</pre>

<p>Names in links are resolved using the same rules as if the name was used inside the element being documented.
In particular, this means that if you have imported a name into the current file, you don’t need to fully qualify it
when you use it in a KDoc comment.</p>

<p>Note that KDoc does not have any syntax for resolving overloaded members in links. Since the Kotlin documentation generation
tool puts the documentation for all overloads of a function on the same page, identifying a specific overloaded function
is not required for the link to work.</p>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/using-gradle.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="using-gradle">Using Gradle<a href="#using-gradle" class="anchor"></a></h1>

<h2 id="plugin-and-versions">Plugin and Versions<a href="#plugin-and-versions" class="anchor"></a></h2>

<p>The <em>kotlin-gradle-plugin</em> compiles Kotlin sources and modules.</p>

<p>Define the version of Kotlin we want to use via <em>kotlin.version</em>. The possible values are:</p>

<ul>
  <li>
    <p>X.Y-SNAPSHOT: Correspond to snapshot version for X.Y releases, updated with every successful build on the CI server. These versions are not really stable and are
only recommended for testing new compiler features. Currently all builds are published as 0.1-SNAPSHOT. To use a snapshot, we need to <a href="#using-snapshot-versions">configure a snapshot repository
in the build.gradle file</a>.</p>
  </li>
  <li>
    <p>X.Y.Z: Correspond to release or milestone versions X.Y.Z, updated manually. These are stable builds. Release versions are published to Maven Central Repository. No extra configuration
is needed in the build.gradle file.</p>
  </li>
</ul>

<p>The correspondence between milestones and versions is displayed below:</p>

<table>
<thead>
<tr>
  <th>Milestone</th>
  <th>Version</th>
</tr>
</thead>
<tbody>

<tr>
  <td>M12.1</td>
  <td>0.12.613</td>
</tr>

<tr>
  <td>M12</td>
  <td>0.12.200</td>
</tr>

<tr>
  <td>M11.1</td>
  <td>0.11.91.1</td>
</tr>

<tr>
  <td>M11</td>
  <td>0.11.91</td>
</tr>

<tr>
  <td>M10.1</td>
  <td>0.10.195</td>
</tr>

<tr>
  <td>M10</td>
  <td>0.10.4</td>
</tr>

<tr>
  <td>M9</td>
  <td>0.9.66</td>
</tr>

<tr>
  <td>M8</td>
  <td>0.8.11</td>
</tr>

<tr>
  <td>M7</td>
  <td>0.7.270</td>
</tr>

<tr>
  <td>M6.2</td>
  <td>0.6.1673</td>
</tr>

<tr>
  <td>M6.1</td>
  <td>0.6.602</td>
</tr>

<tr>
  <td>M6</td>
  <td>0.6.69</td>
</tr>

<tr>
  <td>M5.3</td>
  <td>0.5.998</td>
</tr>

</tbody>
</table>

<h2 id="targeting-the-jvm">Targeting the JVM<a href="#targeting-the-jvm" class="anchor"></a></h2>

<p>To target the JVM, the Kotlin plugin needs to be applied</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">&quot;kotlin&quot;</span></code></pre>

<p>As of M11, Kotlin sources can be mixed with Java sources in the same folder, or in different folders. The default convention is using different folders:</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">project</span>
    <span class="o">-</span> <span class="n">main</span> <span class="o">(</span><span class="n">root</span><span class="o">)</span>
        <span class="o">-</span> <span class="n">kotlin</span>
        <span class="o">-</span> <span class="n">java</span></code></pre>

<p>The corresponding <em>sourceSets</em> property should be updated if not using the default convention</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">sourceSets</span> <span class="o">{</span>
    <span class="n">main</span><span class="o">.</span><span class="na">kotlin</span><span class="o">.</span><span class="na">srcDirs</span> <span class="o">+=</span> <span class="s1">&#39;src/main/myKotlin&#39;</span>
    <span class="n">main</span><span class="o">.</span><span class="na">java</span><span class="o">.</span><span class="na">srcDirs</span> <span class="o">+=</span> <span class="s1">&#39;src/main/myJava&#39;</span>
<span class="o">}</span></code></pre>

<h2 id="targeting-javascript">Targeting JavaScript<a href="#targeting-javascript" class="anchor"></a></h2>

<p>When targeting JavaScript, a different plugin should be applied:</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">&quot;kotlin2js&quot;</span></code></pre>

<p>This plugin only works for Kotlin files so it is recommended to keep Kotlin and Java files separate (if it’s the case that the same project contains Java files). As with
targeting the JVM, if not using the default convention, we need to specify the source folder using <em>sourceSets</em></p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">sourceSets</span> <span class="o">{</span>
    <span class="n">main</span><span class="o">.</span><span class="na">kotlin</span><span class="o">.</span><span class="na">srcDirs</span> <span class="o">+=</span> <span class="s1">&#39;src/main/myKotlin&#39;</span>
<span class="o">}</span></code></pre>

<p>If you want to create a re-usable library, use <code>kotlinOptions.metaInfo</code> to generate additional JS file with binary descriptors.
This file should be distributed together with the result of translation.</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">compileKotlin2Js</span> <span class="o">{</span>
	<span class="n">kotlinOptions</span><span class="o">.</span><span class="na">metaInfo</span> <span class="o">=</span> <span class="kc">true</span>
<span class="o">}</span></code></pre>

<h2 id="targeting-android">Targeting Android<a href="#targeting-android" class="anchor"></a></h2>

<p>Android’s Gradle model is a little different from ordinary Gradle, so if we want to build an Android project written in Kotlin, we need
<em>kotlin-android</em> plugin instead of <em>kotlin</em>:</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">buildscript</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;com.android.application&#39;</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">&#39;kotlin-android&#39;</span></code></pre>

<h3 id="android-studio">Android Studio<a href="#android-studio" class="anchor"></a></h3>

<p>If using Android Studio, the following needs to be added under android:</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">android</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="n">sourceSets</span> <span class="o">{</span>
    <span class="n">main</span><span class="o">.</span><span class="na">java</span><span class="o">.</span><span class="na">srcDirs</span> <span class="o">+=</span> <span class="s1">&#39;src/main/kotlin&#39;</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre>

<p>This lets Android Studio know that the kotlin directory is a source root, so when the project model is loaded into the IDE it will be properly recognized.</p>

<h2 id="configuring-dependencies">Configuring Dependencies<a href="#configuring-dependencies" class="anchor"></a></h2>

<p>We need to add dependencies on kotlin-gradle-plugin and the Kotlin standard library:</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">buildscript</span> <span class="o">{</span>
  <span class="n">repositories</span> <span class="o">{</span>
    <span class="n">mavenCentral</span><span class="o">()</span>
  <span class="o">}</span>
  <span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">classpath</span> <span class="s1">&#39;org.jetbrains.kotlin:kotlin-gradle-plugin:&lt;version&gt;&#39;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">&quot;kotlin&quot;</span> <span class="c1">// or apply plugin: &quot;kotlin2js&quot; if targeting JavaScript</span>

<span class="n">repositories</span> <span class="o">{</span>
  <span class="n">mavenCentral</span><span class="o">()</span>
<span class="o">}</span>

<span class="n">dependencies</span> <span class="o">{</span>
  <span class="n">compile</span> <span class="s1">&#39;org.jetbrains.kotlin:kotlin-stdlib:&lt;version&gt;&#39;</span>
<span class="o">}</span></code></pre>

<h2 id="using-snapshot-versions">Using Snapshot versions<a href="#using-snapshot-versions" class="anchor"></a></h2>

<p>If we want to use a snapshot version (nightly build), we need to add the snapshot repository and change the version to 0.1-SNAPSHOT:</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">buildscript</span> <span class="o">{</span>
  <span class="n">repositories</span> <span class="o">{</span>
    <span class="n">mavenCentral</span><span class="o">()</span>
    <span class="n">maven</span> <span class="o">{</span>
      <span class="n">url</span> <span class="s1">&#39;http://oss.sonatype.org/content/repositories/snapshots&#39;</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">classpath</span> <span class="s1">&#39;org.jetbrains.kotlin:kotlin-gradle-plugin:0.1-SNAPSHOT&#39;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">&quot;kotlin&quot;</span> <span class="c1">// or apply plugin: &quot;kotlin2js&quot; if targeting JavaScript</span>

<span class="n">repositories</span> <span class="o">{</span>
  <span class="n">mavenCentral</span><span class="o">()</span>
  <span class="n">maven</span> <span class="o">{</span>
    <span class="n">url</span> <span class="s1">&#39;http://oss.sonatype.org/content/repositories/snapshots&#39;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">dependencies</span> <span class="o">{</span>
  <span class="n">compile</span> <span class="s1">&#39;org.jetbrains.kotlin:kotlin-stdlib:0.1-SNAPSHOT&#39;</span>
<span class="o">}</span></code></pre>

<h2 id="using-external-annotations">Using External Annotations<a href="#using-external-annotations" class="anchor"></a></h2>

<p>External annotations for JDK and Android SDK will be configured automatically. If we want to add more annotations for some libraries, we need to add the following line to the Gradle script:</p>

<pre><code class="code-block _highlighted lang_groovy"><span class="n">kotlinOptions</span><span class="o">.</span><span class="na">annotations</span> <span class="o">=</span> <span class="n">file</span><span class="o">(</span><span class="s1">&#39;&lt;path to annotations&gt;&#39;</span><span class="o">)</span></code></pre>

<h2 id="examples">Examples<a href="#examples" class="anchor"></a></h2>

<p>The <a href="https://github.com/jetbrains/kotlin">Kotlin Repository</a> contains examples:</p>

<ul>
  <li><a href="https://github.com/JetBrains/kotlin-examples/tree/master/gradle/hello-world">Kotlin</a></li>
  <li><a href="https://github.com/JetBrains/kotlin-examples/tree/master/gradle/mixed-java-kotlin-hello-world">Mixed Java and Kotlin</a></li>
  <li><a href="https://github.com/JetBrains/kotlin-examples/tree/master/gradle/android-mixed-java-kotlin-project">Android</a></li>
  <li><a href="https://github.com/JetBrains/kotlin/tree/master/libraries/tools/kotlin-gradle-plugin/src/test/resources/testProject/kotlin2JsProject">JavaScript</a></li>
</ul>

    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/faq.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="faq">FAQ<a href="#faq" class="anchor"></a></h1>

<h2 id="common-questions">Common Questions<a href="#common-questions" class="anchor"></a></h2>

<h3 id="what-is-kotlin">What is Kotlin?<a href="#what-is-kotlin" class="anchor"></a></h3>

<p>Kotlin is a statically typed language that targets the JVM and JavaScript. It is a general-purpose language intended for industry use.</p>

<p>It is developed by a team at JetBrains although it is an OSS language and has external contributors.</p>

<h3 id="why-a-new-language">Why a new language?<a href="#why-a-new-language" class="anchor"></a></h3>

<p>At JetBrains, we’ve been developing for the Java platform for a long time, and we know how good it is.
On the other hand, we know that the Java programming language has certain limitations and problems that are either impossible
or very hard to fix due to backward-compatibility issues. We know that Java is going to stand long,
but we believe that the community can benefit from a new statically typed JVM-targeted language free of the
legacy trouble and having the features so desperately wanted by the developers.</p>

<p>The main design goals behind this project are</p>

<ul>
  <li>To create a Java-compatible language,</li>
  <li>That compiles at least as fast as Java,</li>
  <li>Make it safer than Java, i.e. statically check for common pitfalls such as null pointer dereference,</li>
  <li>Make it more concise than Java by supporting variable type inference, higher-order functions (closures), extension functions, mixins and first-class delegation, etc;</li>
  <li>And, keeping the useful level of expressiveness (see above), make it way simpler than the most mature competitor – Scala.</li>
</ul>

<h3 id="how-is-it-licensed">How is it licensed?<a href="#how-is-it-licensed" class="anchor"></a></h3>

<p>Kotlin is an OSS language and is licensed under the Apache 2 OSS License. The IntelliJ Plug-in is also OSS.</p>

<p>It is hosted on GitHub and we happily accept contributors</p>

<h3 id="is-it-java-compatible">Is it Java Compatible?<a href="#is-it-java-compatible" class="anchor"></a></h3>

<p>Yes. The compiler emits Java byte-code. Kotlin can call Java, and Java can call Kotlin. See <a href="java-interop.html">Java interoperability</a>.</p>

<h3 id="is-there-tooling-support">Is there tooling support?<a href="#is-there-tooling-support" class="anchor"></a></h3>

<p>Yes. There is an IntelliJ IDEA plugin that is available as an OSS project under the Apache 2 License. You can use Kotlin both
 in the <a href="http://www.jetbrains.com/idea/features/editions_comparison_matrix.html">free OSS Community Edition and Ultimate Edition</a> of IntelliJ IDEA.</p>

<h3 id="is-there-eclipse-support">Is there Eclipse support?<a href="#is-there-eclipse-support" class="anchor"></a></h3>

<p>Yes. Please refer to the <a href="/docs/tutorials/getting-started-eclipse.html">tutorial</a> for installation instructions.</p>

<h3 id="is-there-a-standalone-compiler">Is there a standalone compiler?<a href="#is-there-a-standalone-compiler" class="anchor"></a></h3>

<p>Yes. You can download the standalone compiler and other builds tools from the <a href="https://github.com/JetBrains/kotlin/releases/tag/build-0.12.613">release page on GitHub</a></p>

<h3 id="is-kotlin-a-functional-language">Is Kotlin a Functional Language?<a href="#is-kotlin-a-functional-language" class="anchor"></a></h3>

<p>Kotlin is an Object-Orientated language. However it has support for higher-order functions as well as function literals and top-level functions. In addition, there are
a good number of common functional language constructs in the standard Kotlin library (such as map, flatMap, reduce, etc.). Also, there’s no clear definition on what a Functional Language is so we couldn’t say Kotlin is one.</p>

<h3 id="does-kotlin-support-generics">Does Kotlin support generics?<a href="#does-kotlin-support-generics" class="anchor"></a></h3>

<p>Kotlin supports generics. It also supports declaration-site variance and usage-site variance. Kotlin also does not have wildcard types. Inline functions support reified type parameters.</p>

<h3 id="are-semicolons-required">Are semicolons required?<a href="#are-semicolons-required" class="anchor"></a></h3>

<p>No. They are optional.</p>

<h3 id="are-curly-braces-required">Are curly braces required?<a href="#are-curly-braces-required" class="anchor"></a></h3>

<p>Yes.</p>

<h3 id="why-have-type-declarations-on-the-right">Why have type declarations on the right?<a href="#why-have-type-declarations-on-the-right" class="anchor"></a></h3>

<p>We believe it makes the code more readable. Besides, it enables some nice syntactic features, for instance, it is easy to leave type annotations out. Scala has also
proven pretty well this is not a problem.</p>

<h3 id="will-right-handed-type-declarations-effect-tooling">Will right-handed type declarations effect tooling?<a href="#will-right-handed-type-declarations-effect-tooling" class="anchor"></a></h3>

<p>No. It won’t. We can still implement suggestions for variable names, etc.</p>

<h3 id="is-kotlin-extensible">Is Kotlin extensible?<a href="#is-kotlin-extensible" class="anchor"></a></h3>

<p>We are planning on making it extensible in a few ways: from inline functions to annotations and type loaders.</p>

<h3 id="can-i-embed-my-dsl-into-the-language">Can I embed my DSL into the language?<a href="#can-i-embed-my-dsl-into-the-language" class="anchor"></a></h3>

<p>Yes. Kotlin provides a few features that help: Operator overloading, Custom Control Structures via inline functions, Infix function calls, Extension Functions, Annotations and
language quotations.</p>

<h3 id="what-ecmascript-level-does-the-javascript-support">What ECMAScript level does the JavaScript support?<a href="#what-ecmascript-level-does-the-javascript-support" class="anchor"></a></h3>

<p>Currently at 5.</p>

<h3 id="does-the-javascript-back-end-support-module-systems">Does the JavaScript back-end support module systems?<a href="#does-the-javascript-back-end-support-module-systems" class="anchor"></a></h3>

<p>Yes. There are plans to provide CommonJS and AMD support.</p>


    </article>

<article role="main" class="page-content g-9">
        


<a href="https://github.com/JetBrains/kotlin-web-site/edit/master/docs/reference/comparison-to-java.md"
   class="page-link-to-github"
   target="_blank"
   title="Edit this page on GitHub">
        <i class="github-icon"></i>
        <span class="text">Edit Page</span>
</a>

        <h1 id="comparison-to-java">Comparison to Java<a href="#comparison-to-java" class="anchor"></a></h1>

<h2 id="some-java-issues-addressed-in-kotlin">Some Java issues addressed in Kotlin<a href="#some-java-issues-addressed-in-kotlin" class="anchor"></a></h2>

<p>Kotlin fixes a series of issues that Java suffers from</p>

<ul>
  <li>Null references are <a href="null-safety.html">controlled by the type system</a>.</li>
  <li><a href="java-interop.html">No raw types</a></li>
  <li>Arrays in Kotlin are <a href="basic-types.html#Arrays">invariant</a></li>
  <li>Kotlin has proper <a href="lambdas.html#function-types">function types</a>, as opposed to Java’s SAM-conversions</li>
  <li><a href="generics.html#use-site-variance">Use-site variance</a> without wildcards</li>
  <li>Kotlin does not have checked <a href="exceptions.html">exceptions</a></li>
</ul>

<h2 id="what-java-has-that-kotlin-does-not">What Java has that Kotlin does not<a href="#what-java-has-that-kotlin-does-not" class="anchor"></a></h2>

<ul>
  <li><a href="exceptions.html">Checked exceptions</a></li>
  <li><a href="basic-types.html">Primitive types</a> that are not classes</li>
  <li><a href="classes.html">Static members</a></li>
  <li><a href="properties.html">Non-private fields</a></li>
  <li><a href="generics.html">Wildcard-types</a></li>
</ul>

<h2 id="what-kotlin-has-that-java-does-not">What Kotlin has that Java does not<a href="#what-kotlin-has-that-java-does-not" class="anchor"></a></h2>

<ul>
  <li><a href="lambdas.html">Function literals</a> + <a href="inline-functions.html">Inline functions</a> = performant custom control structures</li>
  <li><a href="extensions.html">Extension functions</a></li>
  <li><a href="null-safety.html">Null-safety</a></li>
  <li><a href="typecasts.html">Smart casts</a></li>
  <li><a href="basic-types.html#strings">String templates</a></li>
  <li><a href="properties.html">Properties</a></li>
  <li><a href="classes.html">Primary constructors</a></li>
  <li><a href="delegation.html">First-class delegation</a></li>
  <li><a href="basic-types.html">Type inference for variable and property types</a></li>
  <li><a href="object-declarations.html">Singletons</a></li>
  <li><a href="generics.html">Declaration-site variance &amp; Type projections</a></li>
  <li><a href="ranges.html">Range expressions</a></li>
  <li><a href="operator-overloading.html">Operator overloading</a></li>
  <li><a href="classes.html#companion-objects">Companion objects</a></li>
</ul>

    </article>

</body>
</html>